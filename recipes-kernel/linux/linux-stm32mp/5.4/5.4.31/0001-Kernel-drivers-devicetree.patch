From 4fb0d83fb9e9316da621d007dd3514d19bff8a6e Mon Sep 17 00:00:00 2001
From: P3NN4 <teodaria@gmail.com>
Date: Tue, 1 Sep 2020 08:38:30 -0400
Subject: [PATCH 1/5] initial modifications

---
 arch/arm/boot/dts/stm32mp15xx-dkx.dtsi | 104 +++++-----
 sound/soc/codecs/Kconfig               |   6 +-
 sound/soc/codecs/ad193x.c              | 119 ++++++++----
 sound/soc/codecs/ad193x.h              |  28 ++-
 sound/soc/stm/Kconfig                  |   8 +
 sound/soc/stm/Makefile                 |   5 +
 sound/soc/stm/stm32_ad1938.c           | 252 +++++++++++++++++++++++++
 7 files changed, 426 insertions(+), 96 deletions(-)
 create mode 100644 sound/soc/stm/stm32_ad1938.c

diff --git a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
index 35169385f..2ba556d8f 100644
--- a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
@@ -65,16 +65,15 @@
 			default-state = "off";
 		};
 	};
-
+	
 	sound {
-		compatible = "audio-graph-card";
-		label = "STM32MP1-DK";
-		routing =
-			"Playback" , "MCLK",
-			"Capture" , "MCLK",
-			"MICL" , "Mic Bias";
-		dais = <&sai2a_port &sai2b_port &i2s2_port>;
-		status = "okay";
+		compatible = "stm,asoc-ad1938";
+		stm,model = "ad1938 expansion card";
+		stm,audio-routing =		
+			"Line Out Jack 1" , "DAC1OUT",
+		"	ADC1IN" , "Line In Jack 1";
+		stm,sai-controller = <&sai2a &sai2b>;
+		stm,audio-codec = <&ad1938 &ad1938>;
 	};
 
 	usb_phy_tuning: usb-phy-tuning {
@@ -223,39 +222,6 @@
 			};
 		};
 	};
-
-	cs42l51: cs42l51@4a {
-		compatible = "cirrus,cs42l51";
-		reg = <0x4a>;
-		#sound-dai-cells = <0>;
-		VL-supply = <&v3v3>;
-		VD-supply = <&v1v8_audio>;
-		VA-supply = <&v1v8_audio>;
-		VAHP-supply = <&v1v8_audio>;
-		reset-gpios = <&gpiog 9 GPIO_ACTIVE_LOW>;
-		clocks = <&sai2a>;
-		clock-names = "MCLK";
-		status = "okay";
-
-		cs42l51_port: port {
-			#address-cells = <1>;
-			#size-cells = <0>;
-
-			cs42l51_tx_endpoint: endpoint@0 {
-				reg = <0>;
-				remote-endpoint = <&sai2a_endpoint>;
-				frame-master;
-				bitclock-master;
-			};
-
-			cs42l51_rx_endpoint: endpoint@1 {
-				reg = <1>;
-				remote-endpoint = <&sai2b_endpoint>;
-				frame-master;
-				bitclock-master;
-			};
-		};
-	};
 };
 
 &i2c4 {
@@ -522,15 +488,16 @@
 	status = "okay";
 };
 
+
 &sai2 {
 	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
 	clock-names = "pclk", "x8k", "x11k";
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_b>;
 	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_b>;
-	status = "okay";
-
+	status = "okay";	
 	sai2a: audio-controller@4400b004 {
+	
 		#clock-cells = <0>;
 		dma-names = "tx";
 		clocks = <&rcc SAI2_K>;
@@ -539,34 +506,30 @@
 
 		sai2a_port: port {
 			sai2a_endpoint: endpoint {
-				remote-endpoint = <&cs42l51_tx_endpoint>;
+				remote-endpoint = <&ad1938_rx_endpoint>;
 				format = "i2s";
-				mclk-fs = <256>;
-				dai-tdm-slot-num = <2>;
-				dai-tdm-slot-width = <32>;
 			};
 		};
 	};
 
 	sai2b: audio-controller@4400b024 {
+		//#clock-cells = <0>;
 		dma-names = "rx";
 		st,sync = <&sai2a 2>;
 		clocks = <&rcc SAI2_K>, <&sai2a>;
-		clock-names = "sai_ck", "MCLK";
+		clock-names = "sai_ck";
 		status = "okay";
 
 		sai2b_port: port {
 			sai2b_endpoint: endpoint {
-				remote-endpoint = <&cs42l51_rx_endpoint>;
+				remote-endpoint = <&ad1938_tx_endpoint>;
 				format = "i2s";
-				mclk-fs = <256>;
-				dai-tdm-slot-num = <2>;
-				dai-tdm-slot-width = <32>;
 			};
 		};
 	};
 };
 
+
 &sdmmc1 {
 	pinctrl-names = "default", "opendrain", "sleep";
 	pinctrl-0 = <&sdmmc1_b4_pins_a>;
@@ -603,7 +566,40 @@
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&spi5_pins_a>;
 	pinctrl-1 = <&spi5_sleep_pins_a>;
-	status = "disabled";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	cs-gpios = <&gpiof 6 0>;
+	status = "okay";
+	
+	ad1938: ad1938@0{
+		compatible = "adi,ad1938";
+		reg = <0>;
+		#sound-dai-cells = <0>;
+		clocks = <&sai2a>;
+		//clock-names = "MCLK";
+    	spi-max-frequency = <1000000>;
+		status = "okay";
+
+
+		ad1938_port: port {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			ad1938_tx_endpoint: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&sai2b_endpoint>;
+				frame-slave;
+				bitclock-slave;
+			};
+
+			ad1938_rx_endpoint: endpoint@1{
+				reg = <1>;
+				remote-endpoint = <&sai2a_endpoint>; //<&sai2b_endpoint>;
+				frame-slave;
+				bitclock-slave;
+			}; 
+		};
+	};
 };
 
 &sram {
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index e5d231a63..b22cd51e5 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -315,14 +315,14 @@ config SND_SOC_AD1836
 	tristate
 
 config SND_SOC_AD193X
-	tristate
+	tristate "Analog Devices AD193X CODEC"
 
 config SND_SOC_AD193X_SPI
-	tristate
+	tristate "Analog Devices AD193X CODEC - SPI"
 	select SND_SOC_AD193X
 
 config SND_SOC_AD193X_I2C
-	tristate
+	tristate "Analog Devices AD193X CODEC - I2C"
 	select SND_SOC_AD193X
 
 config SND_SOC_AD1980
diff --git a/sound/soc/codecs/ad193x.c b/sound/soc/codecs/ad193x.c
index 980e024a5..b77d9b12f 100644
--- a/sound/soc/codecs/ad193x.c
+++ b/sound/soc/codecs/ad193x.c
@@ -4,6 +4,7 @@
  *
  * Copyright 2010 Analog Devices Inc.
  */
+#define DEBUG 1
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -83,7 +84,7 @@ static const struct snd_kcontrol_new ad193x_adc_snd_controls[] = {
 static const struct snd_soc_dapm_widget ad193x_dapm_widgets[] = {
 	SND_SOC_DAPM_DAC("DAC", "Playback", SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_PGA("DAC Output", AD193X_DAC_CTRL0, 0, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("PLL_PWR", AD193X_PLL_CLK_CTRL0, 0, 1, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("PLL_PWR", AD193X_PLL_CLK_CTRL0, 0, 0, NULL, 0),//MD
 	SND_SOC_DAPM_SUPPLY("SYSCLK", AD193X_PLL_CLK_CTRL0, 7, 0, NULL, 0),
 	SND_SOC_DAPM_VMID("VMID"),
 	SND_SOC_DAPM_OUTPUT("DAC1OUT"),
@@ -145,6 +146,8 @@ static inline bool ad193x_has_adc(const struct ad193x_priv *ad193x)
 
 static int ad193x_mute(struct snd_soc_dai *dai, int mute)
 {
+				printk(" test ad1938 component ad193x_mute");
+
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(dai->component);
 
 	if (mute)
@@ -161,6 +164,8 @@ static int ad193x_mute(struct snd_soc_dai *dai, int mute)
 static int ad193x_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 			       unsigned int rx_mask, int slots, int width)
 {
+			printk(" test ad1938 component ad193x_set_tdm_slot");
+
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(dai->component);
 	unsigned int channels;
 
@@ -194,6 +199,9 @@ static int ad193x_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 static int ad193x_set_dai_fmt(struct snd_soc_dai *codec_dai,
 		unsigned int fmt)
 {
+		printk(" test ad1938 component ad193x_set_dai_fmt");
+	return 0;
+
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(codec_dai->component);
 	unsigned int adc_serfmt = 0;
 	unsigned int dac_serfmt = 0;
@@ -281,38 +289,66 @@ static int ad193x_set_dai_fmt(struct snd_soc_dai *codec_dai,
 static int ad193x_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 		int clk_id, unsigned int freq, int dir)
 {
-	struct snd_soc_component *component = codec_dai->component;
-	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
-	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
-
-	if (clk_id == AD193X_SYSCLK_MCLK) {
-		/* MCLK must be 512 x fs */
-		if (dir == SND_SOC_CLOCK_OUT || freq != 24576000)
-			return -EINVAL;
+	printk(" test ad1938 component ad193x_set_dai_sysclk");
+
+//	struct snd_soc_component *component = codec_dai->component;
+//	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+//	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
+//
+//	if (clk_id == AD193X_SYSCLK_MCLK) {
+//		/* MCLK must be 512 x fs */
+//		if (dir == SND_SOC_CLOCK_OUT || freq != 24576000)
+//			return -EINVAL;
+//
+//		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
+//				   AD193X_PLL_SRC_MASK,
+//				   AD193X_PLL_DAC_SRC_MCLK |
+//				   AD193X_PLL_CLK_SRC_MCLK);
+//
+//		snd_soc_dapm_sync(dapm);
+//		return 0;
+//	}
+//	
+//	switch (freq) {
+//	case 12288000:
+//	case 18432000:
+//	case 24576000:
+//	case 36864000:
+//		ad193x->sysclk = freq;
+//		return 0;
+//	}
+//	return -EINVAL;
+	return 0;
+}
 
-		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
-				   AD193X_PLL_SRC_MASK,
-				   AD193X_PLL_DAC_SRC_MCLK |
-				   AD193X_PLL_CLK_SRC_MCLK);
+static int ad193x_set_pll(struct snd_soc_dai *codec_dai, int pll_id, int source,
+		unsigned int freq_in, unsigned int freq_out)
+{
+//	struct snd_soc_component *component = codec_dai->component;
+//	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+//	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
+//	
+//	
+//	
+//			regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
+//				   AD193X_PLL_SRC_MASK,
+//				   AD193X_PLL_DAC_SRC_MCLK |
+//				   AD193X_PLL_CLK_SRC_MCLK);
+//
+//		snd_soc_dapm_sync(dapm);
+//	
+//	
+//   return -EINVAL;
+	
+	return 0;
 
-		snd_soc_dapm_sync(dapm);
-		return 0;
-	}
-	switch (freq) {
-	case 12288000:
-	case 18432000:
-	case 24576000:
-	case 36864000:
-		ad193x->sysclk = freq;
-		return 0;
-	}
-	return -EINVAL;
 }
 
 static int ad193x_hw_params(struct snd_pcm_substream *substream,
 		struct snd_pcm_hw_params *params,
 		struct snd_soc_dai *dai)
 {
+	return 0;
 	int word_len = 0, master_rate = 0;
 	struct snd_soc_component *component = dai->component;
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
@@ -346,8 +382,8 @@ static int ad193x_hw_params(struct snd_pcm_substream *substream,
 		break;
 	}
 
-	regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
-			    AD193X_PLL_INPUT_MASK, master_rate);
+/*	regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+			    AD193X_PLL_INPUT_MASK, master_rate);*/
 
 	regmap_update_bits(ad193x->regmap, AD193X_DAC_CTRL2,
 			    AD193X_DAC_WORD_LEN_MASK,
@@ -356,13 +392,15 @@ static int ad193x_hw_params(struct snd_pcm_substream *substream,
 	if (ad193x_has_adc(ad193x))
 		regmap_update_bits(ad193x->regmap, AD193X_ADC_CTRL1,
 				   AD193X_ADC_WORD_LEN_MASK, word_len);
-
+printk(" test ad1938 component ad193x_hw_params");
 	return 0;
 }
 
 static int ad193x_startup(struct snd_pcm_substream *substream,
 			  struct snd_soc_dai *dai)
 {
+	printk("test ad1938 component ad193x_startup");
+
 	return snd_pcm_hw_constraint_list(substream->runtime, 0,
 				   SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
 				   &constr);
@@ -374,6 +412,7 @@ static const struct snd_soc_dai_ops ad193x_dai_ops = {
 	.digital_mute = ad193x_mute,
 	.set_tdm_slot = ad193x_set_tdm_slot,
 	.set_sysclk	= ad193x_set_dai_sysclk,
+	.set_pll = ad193x_set_pll,
 	.set_fmt = ad193x_set_dai_fmt,
 };
 
@@ -417,11 +456,11 @@ static struct snd_soc_dai_driver ad193x_no_adc_dai = {
 static void ad193x_reg_default_init(struct ad193x_priv *ad193x)
 {
 	static const struct reg_sequence reg_init[] = {
-		{  0, 0x99 },	/* PLL_CLK_CTRL0: pll input: mclki/xi 12.288Mhz */
-		{  1, 0x04 },	/* PLL_CLK_CTRL1: no on-chip Vref */
-		{  2, 0x40 },	/* DAC_CTRL0: TDM mode */
+		{  0, 0xD8 },	/* PLL_CLK_CTRL0: pll input: mclki/xi 12.288Mhz */ /*0b10100000*/
+		{  1, 0x04 },	/* PLL_CLK_CTRL1: no on-chip Vref */ /*0b00000100*/
+		{  2, 0x00 },	/* DAC_CTRL0: TDM mode */ /*0x40*/ /*0b00000000*/
 		{  3, 0x00 },	/* DAC_CTRL1: reset */
-		{  4, 0x1A },	/* DAC_CTRL2: 48kHz de-emphasis, unmute dac */
+		{  4, 0x1A },	/* DAC_CTRL2: 48kHz de-emphasis, unmute dac */ /*0b00000010*/
 		{  5, 0x00 },	/* DAC_CHNL_MUTE: unmute DAC channels */
 		{  6, 0x00 },	/* DAC_L1_VOL: no attenuation */
 		{  7, 0x00 },	/* DAC_R1_VOL: no attenuation */
@@ -481,10 +520,19 @@ static int ad193x_component_probe(struct snd_soc_component *component)
 		if (ret)
 			return ret;
 	}
+	
+	
 
 	return 0;
 }
 
+///*static int ad193x_of_xlate_dai_id(struct snd_soc_component *component,
+//				   struct device_node *endpoint)
+//{
+//	/* return dai id 0, whatever the endpoint index */
+//	return 0;
+//}*/
+//
 static const struct snd_soc_component_driver soc_component_dev_ad193x = {
 	.probe			= ad193x_component_probe,
 	.controls		= ad193x_snd_controls,
@@ -493,12 +541,15 @@ static const struct snd_soc_component_driver soc_component_dev_ad193x = {
 	.num_dapm_widgets	= ARRAY_SIZE(ad193x_dapm_widgets),
 	.dapm_routes		= audio_paths,
 	.num_dapm_routes	= ARRAY_SIZE(audio_paths),
+//	.of_xlate_dai_id	= ad193x_of_xlate_dai_id,
 	.idle_bias_on		= 1,
 	.use_pmdown_time	= 1,
 	.endianness		= 1,
 	.non_legacy_dai_naming	= 1,
 };
 
+
+
 const struct regmap_config ad193x_regmap_config = {
 	.max_register = AD193X_NUM_REGS - 1,
 };
@@ -507,8 +558,8 @@ EXPORT_SYMBOL_GPL(ad193x_regmap_config);
 int ad193x_probe(struct device *dev, struct regmap *regmap,
 		 enum ad193x_type type)
 {
-	struct ad193x_priv *ad193x;
-
+	struct ad193x_priv *ad193x;	
+	
 	if (IS_ERR(regmap))
 		return PTR_ERR(regmap);
 
diff --git a/sound/soc/codecs/ad193x.h b/sound/soc/codecs/ad193x.h
index 377854712..7ef7fa93d 100644
--- a/sound/soc/codecs/ad193x.h
+++ b/sound/soc/codecs/ad193x.h
@@ -23,23 +23,41 @@ int ad193x_probe(struct device *dev, struct regmap *regmap,
 		 enum ad193x_type type);
 
 #define AD193X_PLL_CLK_CTRL0    0x00
-#define AD193X_PLL_POWERDOWN           0x01
+
+#define AD193X_PLL_POWERDOWN    0x01
 #define AD193X_PLL_INPUT_MASK   0x6
 #define AD193X_PLL_INPUT_256    (0 << 1)
 #define AD193X_PLL_INPUT_384    (1 << 1)
 #define AD193X_PLL_INPUT_512    (2 << 1)
 #define AD193X_PLL_INPUT_768    (3 << 1)
+#define AD193X_PLL_OUTPUT_MASK  0x18
+#define AD193X_PLL_OUTPUT_XTAL  (0 << 3)
+#define AD193X_PLL_OUTPUT_256FS (1 << 3)
+#define AD193X_PLL_OUTPUT_512FS (2 << 3)
+#define AD193X_PLL_OUTPUT_OFF   (3 << 3)
+#define AD193X_PLL_IN_MASK  	0x60
+#define AD193X_PLL_IN_MCLKI     (0 << 5)
+#define AD193X_PLL_IN_DLRCLK    (1 << 5)
+#define AD193X_PLL_IN_ALRCLK    (2 << 5)
+#define AD193X_PLL_ENABLE       (1 << 7)
+
 #define AD193X_PLL_CLK_CTRL1    0x01
-#define AD193X_PLL_SRC_MASK	0x03
+
+#define AD193X_PLL_SRC_MASK		0x03
 #define AD193X_PLL_DAC_SRC_PLL  0
 #define AD193X_PLL_DAC_SRC_MCLK 1
-#define AD193X_PLL_CLK_SRC_PLL  (0 << 1)
-#define AD193X_PLL_CLK_SRC_MCLK	(1 << 1)
+#define AD193X_PLL_ADC_SRC_PLL  (0 << 1)
+#define AD193X_PLL_ADC_SRC_MCLK	(1 << 1)
+#define AD193X_PLL_SRC_MASK		0x04
+#define AD193X_PLL_VREF_ENABLE  (1 << 2)
+
 #define AD193X_DAC_CTRL0        0x02
-#define AD193X_DAC_POWERDOWN           0x01
+
+#define AD193X_DAC_POWERDOWN        0x01
 #define AD193X_DAC_SERFMT_MASK		0xC0
 #define AD193X_DAC_SERFMT_STEREO	(0 << 6)
 #define AD193X_DAC_SERFMT_TDM		(1 << 6)
+
 #define AD193X_DAC_CTRL1        0x03
 #define AD193X_DAC_CHAN_SHFT    1
 #define AD193X_DAC_CHAN_MASK    (3 << AD193X_DAC_CHAN_SHFT)
diff --git a/sound/soc/stm/Kconfig b/sound/soc/stm/Kconfig
index bbade257f..823c81f2d 100644
--- a/sound/soc/stm/Kconfig
+++ b/sound/soc/stm/Kconfig
@@ -1,6 +1,14 @@
 # SPDX-License-Identifier: GPL-2.0-only
 menu "STMicroelectronics STM32 SOC audio support"
 
+config SND_SOC_STM32_AD1938
+	tristate "STM32 AD1930 machine driver"
+	depends on (ARCH_STM32 && OF) || COMPILE_TEST
+	depends on SND_SOC_STM32_SAI
+	depends on SND_SOC
+	help
+	  Say Y if you want to enable ad1938 board
+
 config SND_SOC_STM32_SAI
 	tristate "STM32 SAI interface (Serial Audio Interface) support"
 	depends on (ARCH_STM32 && OF) || COMPILE_TEST
diff --git a/sound/soc/stm/Makefile b/sound/soc/stm/Makefile
index 3143c0b47..5c9f66b5c 100644
--- a/sound/soc/stm/Makefile
+++ b/sound/soc/stm/Makefile
@@ -16,3 +16,8 @@ obj-$(CONFIG_SND_SOC_STM32_SPDIFRX) += snd-soc-stm32-spdifrx.o
 
 #DFSDM
 obj-$(CONFIG_SND_SOC_STM32_DFSDM) += stm32_adfsdm.o
+
+#AD1938
+obj-$(CONFIG_SND_SOC_STM32_AD1938) += stm32_ad1938.o
+
+
diff --git a/sound/soc/stm/stm32_ad1938.c b/sound/soc/stm/stm32_ad1938.c
new file mode 100644
index 000000000..3a3a1ae7a
--- /dev/null
+++ b/sound/soc/stm/stm32_ad1938.c
@@ -0,0 +1,252 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * stm32_ad1938 - ST ASoC driver for boards with ad1938 codec.
+ *
+ * Copyright (C) 2012 STMicroelectronics
+ *
+ * Author: Matteo D'Aria <matteo.daria@st.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+
+#include <sound/soc.h>
+
+#include "../codecs/ad193x.h"
+#include "stm32_sai.h"
+
+static const struct snd_soc_dapm_widget stm_asoc_ad1938_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("Line In Jack 1", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack 2", NULL),
+	SND_SOC_DAPM_HP("Line Out Jack 1", NULL),
+	SND_SOC_DAPM_HP("Line Out Jack 2", NULL),	
+};
+
+static int stm_asoc_ad1938_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+//	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+//	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+//	struct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);
+//	struct platform_device *pdev_sync_provider = of_find_device_by_node(sai->np_sync_provider_sai_sub);
+//	struct stm32_sai_sub_data *sai_provider = platform_get_drvdata(pdev_sync_provider);
+
+	
+//	int ret;
+//
+//	/*MD: These functions to setup codec. Depends on the function which are
+//	defined in the codec driver, under snd_soc_dai_ops (I believe)
+//	*/
+//	ret = snd_soc_dai_set_pll(codec_dai, WM8904_FLL_MCLK, WM8904_FLL_MCLK,
+//		32768, params_rate(params) * 256);
+//	if (ret < 0) {
+//		pr_err("%s - failed to set wm8904 codec PLL.", __func__);
+//		return ret;
+//	}
+//
+//	/*
+//	 * As here wm8904 use FLL output as its system clock
+//	 * so calling set_sysclk won't care freq parameter
+//	 * then we pass 0
+//	 */
+//	ret = snd_soc_dai_set_sysclk(codec_dai, WM8904_CLK_FLL,
+//			0, SND_SOC_CLOCK_IN);
+//	if (ret < 0) {
+//		pr_err("%s -failed to set wm8904 SYSCLK\n", __func__);
+//		return ret;
+//	}
+//
+printk(" MACHINE HW PARAM ");
+	return 0;
+}
+
+static const struct snd_soc_ops stm_asoc_ad1938_ops = {
+	.hw_params = stm_asoc_ad1938_hw_params,
+};
+
+SND_SOC_DAILINK_DEFS(pcm1,
+	DAILINK_COMP_ARRAY(COMP_EMPTY()),
+	DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "ad193x-hifi")),
+	DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(pcm2,
+	DAILINK_COMP_ARRAY(COMP_EMPTY()),
+	DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "ad193x-hifi")),
+	DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+/* Slide 8 */
+static struct snd_soc_dai_link stm_asoc_ad1938_dailink[] = {
+	{
+	.name = "ad1938_1",
+	.stream_name = "AD1938 PCM1",
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+		| SND_SOC_DAIFMT_NB_NF
+		| SND_SOC_DAIFMT_CBS_CFS,
+	.ops = &stm_asoc_ad1938_ops,
+	SND_SOC_DAILINK_REG(pcm1),
+	},
+	{
+	.name = "ad1938_2",
+	.stream_name = "AD1938 PCM2",
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+		| SND_SOC_DAIFMT_NB_NF
+		| SND_SOC_DAIFMT_CBS_CFS,
+	.ops = &stm_asoc_ad1938_ops,
+	SND_SOC_DAILINK_REG(pcm2),		
+	}		
+};
+
+/* Slide 7 */
+static struct snd_soc_card stm_asoc_ad1938_card = {
+	.name = "stm_asoc_ad1938",
+	.owner = THIS_MODULE,
+	.dai_link = stm_asoc_ad1938_dailink,
+	.num_links = 2,
+	.dapm_widgets = stm_asoc_ad1938_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(stm_asoc_ad1938_dapm_widgets),
+	.fully_routed = true,
+};
+
+static int stm_asoc_ad1938_dt_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *codec_np, *cpu_np;
+	struct snd_soc_card *card = &stm_asoc_ad1938_card;
+	struct snd_soc_dai_link *dailink1 = &stm_asoc_ad1938_dailink[0];
+    struct snd_soc_dai_link *dailink2 = &stm_asoc_ad1938_dailink[1];
+
+	int ret;
+
+	if (!np) {
+		dev_err(&pdev->dev, "only device tree supported\n");
+		return -EINVAL;
+	}
+
+	ret = snd_soc_of_parse_card_name(card, "stm,model"); /* Looks to the DT bindings */
+	if (ret) {
+		dev_err(&pdev->dev, "failed to parse card name\n");
+		return ret;
+	}
+
+	ret = snd_soc_of_parse_audio_routing(card, "stm,audio-routing"); /* Looks to the DT bindings */
+	if (ret) {
+		dev_err(&pdev->dev, "failed to parse audio routing\n");
+		return ret;
+	}
+	
+	cpu_np = of_parse_phandle(np, "stm,sai-controller", 0); /* Looks to the DT bindings */
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "failed to get dai and pcm info\n");
+		ret = -EINVAL;
+		return ret;
+	}
+	dailink1->cpus->of_node = cpu_np;
+	dailink1->platforms->of_node = cpu_np;
+	of_node_put(cpu_np);
+
+	codec_np = of_parse_phandle(np, "stm,audio-codec", 0); /* Looks to the DT bindings */
+	if (!codec_np) {
+		dev_err(&pdev->dev, "failed to get codec info\n");
+		ret = -EINVAL;
+		return ret;
+	}
+	dailink1->codecs->of_node = codec_np;
+	of_node_put(codec_np);
+
+	cpu_np = of_parse_phandle(np, "stm,sai-controller", 1); /* Looks to the DT bindings */
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "failed to get dai and pcm info\n");
+		ret = -EINVAL;
+		return ret;
+	}
+
+	dailink2->cpus->of_node = cpu_np;
+	dailink2->platforms->of_node = cpu_np;
+	of_node_put(cpu_np);
+	
+	codec_np = of_parse_phandle(np, "stm,audio-codec", 0); /* Looks to the DT bindings */
+	if (!codec_np) {
+		dev_err(&pdev->dev, "failed to get codec info\n");
+		ret = -EINVAL;
+		return ret;
+	}
+	dailink2->codecs->of_node = codec_np;
+	of_node_put(codec_np);
+
+
+	return 0;
+}
+
+static int stm_asoc_ad1938_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &stm_asoc_ad1938_card;
+	//struct snd_soc_dai_link *dailink = &stm_asoc_ad1938_dailink;
+	int id, ret;
+
+	card->dev = &pdev->dev;
+	ret = stm_asoc_ad1938_dt_init(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to init dt info\n");
+		return ret;
+	}
+
+	/*id = of_alias_get_id((struct device_node *)dailink->cpus->of_node, "ssc");
+	ret = atmel_ssc_set_audio(id);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "failed to set SSC %d for audio\n", id);
+		return ret;
+	}*/ /*MD: ??? */
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed\n");
+		goto err_set_audio;
+	}
+
+	return 0;
+
+err_set_audio:
+	//atmel_ssc_put_audio(id);
+	return ret;
+}
+
+static int stm_asoc_1938_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+//	struct snd_soc_dai_link *dailink = &stm_asoc_ad1938_dailink;
+	int id;
+
+	//id = of_alias_get_id((struct device_node *)dailink->cpus->of_node, "ssc");
+
+	snd_soc_unregister_card(card);
+	//atmel_ssc_put_audio(id);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id stm_asoc_ad1938_dt_ids[] = {
+	{ .compatible = "stm,asoc-ad1938", },    /*DT compatible property */
+	{ }
+};
+MODULE_DEVICE_TABLE(of, stm_asoc_ad1938_dt_ids);
+#endif
+
+static struct platform_driver stm_asoc_ad1938_driver = {
+	.driver = {
+		.name = "stm-ad1938-audio",
+		.of_match_table = of_match_ptr(stm_asoc_ad1938_dt_ids),
+		.pm		= &snd_soc_pm_ops,
+	},
+	.probe = stm_asoc_ad1938_probe,
+	.remove = stm_asoc_1938_remove,
+};
+
+module_platform_driver(stm_asoc_ad1938_driver);
+
+/* Module information */
+MODULE_AUTHOR("Matteo D'Aria <matteo.daria@st.com>");
+MODULE_DESCRIPTION("ALSA SoC machine driver for STM32MP1DK with AD1938 codec");
+MODULE_LICENSE("GPL");
-- 
2.17.1


From 2bd6a020dac747c05927eaf2f07d27382ebc927a Mon Sep 17 00:00:00 2001
From: P3NN4 <teodaria@gmail.com>
Date: Tue, 1 Sep 2020 17:39:27 -0400
Subject: [PATCH 2/5] modified dt and ad1938 drivers + machine drivers

---
 arch/arm/boot/dts/stm32mp15xx-dkx.dtsi |   6 +-
 sound/soc/codecs/ad193x.c              | 187 ++++++++++++++++---------
 sound/soc/codecs/ad193x.h              | 136 +++++++++++++++++-
 sound/soc/stm/stm32_ad1938.c           |  81 ++++-------
 4 files changed, 286 insertions(+), 124 deletions(-)

diff --git a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
index 2ba556d8f..a0eb97108 100644
--- a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
@@ -71,7 +71,11 @@
 		stm,model = "ad1938 expansion card";
 		stm,audio-routing =		
 			"Line Out Jack 1" , "DAC1OUT",
-		"	ADC1IN" , "Line In Jack 1";
+			"Line Out Jack 2" , "DAC2OUT",
+			"Headphones Left" , "DAC3OUT",
+			"Headphones Right" , "DAC4OUT",
+			"ADC1IN" , "Line In Jack 1",
+			"ADC2IN" , "Line In Jack 2";
 		stm,sai-controller = <&sai2a &sai2b>;
 		stm,audio-codec = <&ad1938 &ad1938>;
 	};
diff --git a/sound/soc/codecs/ad193x.c b/sound/soc/codecs/ad193x.c
index b77d9b12f..4ad4022b8 100644
--- a/sound/soc/codecs/ad193x.c
+++ b/sound/soc/codecs/ad193x.c
@@ -84,7 +84,7 @@ static const struct snd_kcontrol_new ad193x_adc_snd_controls[] = {
 static const struct snd_soc_dapm_widget ad193x_dapm_widgets[] = {
 	SND_SOC_DAPM_DAC("DAC", "Playback", SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_PGA("DAC Output", AD193X_DAC_CTRL0, 0, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("PLL_PWR", AD193X_PLL_CLK_CTRL0, 0, 0, NULL, 0),//MD
+	SND_SOC_DAPM_SUPPLY("PLL_PWR", AD193X_PLL_CLK_CTRL0, 0, 1, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("SYSCLK", AD193X_PLL_CLK_CTRL0, 7, 0, NULL, 0),
 	SND_SOC_DAPM_VMID("VMID"),
 	SND_SOC_DAPM_OUTPUT("DAC1OUT"),
@@ -106,7 +106,7 @@ static int ad193x_check_pll(struct snd_soc_dapm_widget *source,
 	struct snd_soc_component *component = snd_soc_dapm_to_component(source->dapm);
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
 
-	return !!ad193x->sysclk;
+	return !ad193x->sysclk;
 }
 
 static const struct snd_soc_dapm_route audio_paths[] = {
@@ -146,7 +146,7 @@ static inline bool ad193x_has_adc(const struct ad193x_priv *ad193x)
 
 static int ad193x_mute(struct snd_soc_dai *dai, int mute)
 {
-				printk(" test ad1938 component ad193x_mute");
+				printk(" test ad1938 component ad193x_mute %d", mute);
 
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(dai->component);
 
@@ -289,57 +289,128 @@ static int ad193x_set_dai_fmt(struct snd_soc_dai *codec_dai,
 static int ad193x_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 		int clk_id, unsigned int freq, int dir)
 {
-	printk(" test ad1938 component ad193x_set_dai_sysclk");
-
-//	struct snd_soc_component *component = codec_dai->component;
-//	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
-//	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
-//
-//	if (clk_id == AD193X_SYSCLK_MCLK) {
-//		/* MCLK must be 512 x fs */
-//		if (dir == SND_SOC_CLOCK_OUT || freq != 24576000)
-//			return -EINVAL;
-//
-//		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
-//				   AD193X_PLL_SRC_MASK,
-//				   AD193X_PLL_DAC_SRC_MCLK |
-//				   AD193X_PLL_CLK_SRC_MCLK);
-//
-//		snd_soc_dapm_sync(dapm);
-//		return 0;
-//	}
-//	
-//	switch (freq) {
-//	case 12288000:
-//	case 18432000:
-//	case 24576000:
-//	case 36864000:
-//		ad193x->sysclk = freq;
-//		return 0;
-//	}
-//	return -EINVAL;
-	return 0;
+
+	struct snd_soc_component *component = codec_dai->component;
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
+		printk(" test ad1938 component ad193x_set_dai_sysclk");
+
+	if (clk_id == AD193X_SYSCLK_MCLK) {
+		/* MCLK must be 512 x fs */
+		if (dir == SND_SOC_CLOCK_OUT || freq != 24576000)
+			return -EINVAL;
+
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
+				   AD193X_PLL_SRC_MASK,
+				   AD193X_PLL_DAC_SRC_MCLK |
+				   AD193X_PLL_ADC_SRC_MCLK);
+
+		snd_soc_dapm_sync(dapm);
+		ad193x->sysclk = freq;
+		return 0;
+	}
+	else if (clk_id == AD193X_SYSCLK_PLL) {
+		
+		if (dir != SND_SOC_CLOCK_IN)
+			return -EINVAL;
+		
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
+				  AD193X_PLL_SRC_MASK,
+				  AD193X_PLL_DAC_SRC_PLL |
+				  AD193X_PLL_ADC_SRC_PLL);
+		snd_soc_dapm_sync(dapm);		
+		return 0;	
+	}
+
+	return -EINVAL;
+
 }
 
 static int ad193x_set_pll(struct snd_soc_dai *codec_dai, int pll_id, int source,
 		unsigned int freq_in, unsigned int freq_out)
 {
-//	struct snd_soc_component *component = codec_dai->component;
-//	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
-//	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
-//	
-//	
-//	
-//			regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
-//				   AD193X_PLL_SRC_MASK,
-//				   AD193X_PLL_DAC_SRC_MCLK |
-//				   AD193X_PLL_CLK_SRC_MCLK);
-//
-//		snd_soc_dapm_sync(dapm);
-//	
-//	
-//   return -EINVAL;
+	struct snd_soc_component *component = codec_dai->component;
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
+	
+		printk("test ad193x_set_pll freq in: %d", freq_in);
+			printk("test ad193x_set_pll freq out: %d", freq_out);
+			printk("test ad193x_set_pll id  : %d", pll_id);
+			printk("test ad193x_set_pll source: %d", source);
+	
+	int master_rate;
+	
+	if (pll_id != AD193X_PLL_ID)
+			return -EINVAL;	
+	
+	switch (freq_in) {
+	case 12288000:
+		master_rate = AD193X_PLL_INPUT_256;
+		break;
+	case 18432000:
+		master_rate = AD193X_PLL_INPUT_384;
+		break;
+	case 24576000:
+		master_rate = AD193X_PLL_INPUT_512;
+		break;
+	case 36864000:
+		master_rate = AD193X_PLL_INPUT_768;
+		break;
+	default:
+		master_rate = 0;
+		break;
+	}
+
+	
+	if (freq_out != AD193X_PLL_X0_256VCO && freq_out != AD193X_PLL_X0_512VCO && freq_out != 0)
+		/* error if OUT not supported */
+		return -EINVAL; 	
 	
+	switch (source) {
+		case AD193X_PLL_INPUT_XTAL:
+			if (freq_out != 0)
+				/* If XTAL, XO is used, no output possible */
+				return -EINVAL; 
+		/* Set input ratio */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+			   AD193X_PLL_INPUT_MASK, master_rate);
+		/* Activate oscillator */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+			   AD193X_PLL_MCLKXO_MASK, AD193X_PLL_X0_XTAL);
+		/* choose XI as PLL input */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+			   AD193X_PLL_SOURCE_MASK, AD193X_PLL_SOURCE_MCLKXI);	
+		break;
+	case AD193X_PLL_INPUT_MCLK:
+		/* Set input ratio */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+			   AD193X_PLL_INPUT_MASK, master_rate);
+		/* Set output */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_MCLKXO_MASK, freq_out);	
+		/* choose MCLK as PLL input */			
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_SOURCE_MASK, AD193X_PLL_SOURCE_MCLKXI);				
+		break;
+	case AD193X_PLL_INPUT_DLRCLK:
+		/* Set output */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_MCLKXO_MASK, freq_out);
+		/* choose DLRCLK as PLL input */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_SOURCE_MASK, AD193X_PLL_SOURCE_DLRCLK );			
+		break;			
+	case AD193X_PLL_INPUT_ALRCLK:
+			/* Set output */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_MCLKXO_MASK, freq_out);
+		/* choose ALRCLK as PLL input */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_SOURCE_MASK, AD193X_PLL_SOURCE_ALRCLK );	
+		break;
+	}
+
+    snd_soc_dapm_sync(dapm); // ?
 	return 0;
 
 }
@@ -392,7 +463,7 @@ static int ad193x_hw_params(struct snd_pcm_substream *substream,
 	if (ad193x_has_adc(ad193x))
 		regmap_update_bits(ad193x->regmap, AD193X_ADC_CTRL1,
 				   AD193X_ADC_WORD_LEN_MASK, word_len);
-printk(" test ad1938 component ad193x_hw_params");
+	
 	return 0;
 }
 
@@ -456,11 +527,11 @@ static struct snd_soc_dai_driver ad193x_no_adc_dai = {
 static void ad193x_reg_default_init(struct ad193x_priv *ad193x)
 {
 	static const struct reg_sequence reg_init[] = {
-		{  0, 0xD8 },	/* PLL_CLK_CTRL0: pll input: mclki/xi 12.288Mhz */ /*0b10100000*/
-		{  1, 0x04 },	/* PLL_CLK_CTRL1: no on-chip Vref */ /*0b00000100*/
-		{  2, 0x00 },	/* DAC_CTRL0: TDM mode */ /*0x40*/ /*0b00000000*/
+		{  0, 0x99 },	/* PLL_CLK_CTRL0: pll input: mclki/xi 12.288Mhz */
+		{  1, 0x04 },	/* PLL_CLK_CTRL1: no on-chip Vref */
+		{  2, 0x40 },	/* DAC_CTRL0: TDM mode */
 		{  3, 0x00 },	/* DAC_CTRL1: reset */
-		{  4, 0x1A },	/* DAC_CTRL2: 48kHz de-emphasis, unmute dac */ /*0b00000010*/
+		{  4, 0x1A },	/* DAC_CTRL2: 48kHz de-emphasis, unmute dac */
 		{  5, 0x00 },	/* DAC_CHNL_MUTE: unmute DAC channels */
 		{  6, 0x00 },	/* DAC_L1_VOL: no attenuation */
 		{  7, 0x00 },	/* DAC_R1_VOL: no attenuation */
@@ -526,13 +597,6 @@ static int ad193x_component_probe(struct snd_soc_component *component)
 	return 0;
 }
 
-///*static int ad193x_of_xlate_dai_id(struct snd_soc_component *component,
-//				   struct device_node *endpoint)
-//{
-//	/* return dai id 0, whatever the endpoint index */
-//	return 0;
-//}*/
-//
 static const struct snd_soc_component_driver soc_component_dev_ad193x = {
 	.probe			= ad193x_component_probe,
 	.controls		= ad193x_snd_controls,
@@ -541,15 +605,12 @@ static const struct snd_soc_component_driver soc_component_dev_ad193x = {
 	.num_dapm_widgets	= ARRAY_SIZE(ad193x_dapm_widgets),
 	.dapm_routes		= audio_paths,
 	.num_dapm_routes	= ARRAY_SIZE(audio_paths),
-//	.of_xlate_dai_id	= ad193x_of_xlate_dai_id,
 	.idle_bias_on		= 1,
 	.use_pmdown_time	= 1,
 	.endianness		= 1,
 	.non_legacy_dai_naming	= 1,
 };
 
-
-
 const struct regmap_config ad193x_regmap_config = {
 	.max_register = AD193X_NUM_REGS - 1,
 };
diff --git a/sound/soc/codecs/ad193x.h b/sound/soc/codecs/ad193x.h
index 7ef7fa93d..9cbcabbe3 100644
--- a/sound/soc/codecs/ad193x.h
+++ b/sound/soc/codecs/ad193x.h
@@ -5,7 +5,7 @@
  * Copyright 2010 Analog Devices Inc.
  */
 
-#ifndef __AD193X_H__
+/*#ifndef __AD193X_H__
 #define __AD193X_H__
 
 #include <linux/regmap.h>
@@ -23,7 +23,6 @@ int ad193x_probe(struct device *dev, struct regmap *regmap,
 		 enum ad193x_type type);
 
 #define AD193X_PLL_CLK_CTRL0    0x00
-
 #define AD193X_PLL_POWERDOWN    0x01
 #define AD193X_PLL_INPUT_MASK   0x6
 #define AD193X_PLL_INPUT_256    (0 << 1)
@@ -48,16 +47,132 @@ int ad193x_probe(struct device *dev, struct regmap *regmap,
 #define AD193X_PLL_DAC_SRC_MCLK 1
 #define AD193X_PLL_ADC_SRC_PLL  (0 << 1)
 #define AD193X_PLL_ADC_SRC_MCLK	(1 << 1)
-#define AD193X_PLL_SRC_MASK		0x04
-#define AD193X_PLL_VREF_ENABLE  (1 << 2)
-
 #define AD193X_DAC_CTRL0        0x02
-
 #define AD193X_DAC_POWERDOWN        0x01
 #define AD193X_DAC_SERFMT_MASK		0xC0
 #define AD193X_DAC_SERFMT_STEREO	(0 << 6)
 #define AD193X_DAC_SERFMT_TDM		(1 << 6)
+#define AD193X_DAC_CTRL1        0x03
+#define AD193X_DAC_CHAN_SHFT    1
+#define AD193X_DAC_CHAN_MASK    (3 << AD193X_DAC_CHAN_SHFT)
+#define AD193X_DAC_LCR_MASTER   (1 << 4)
+#define AD193X_DAC_BCLK_MASTER  (1 << 5)
+#define AD193X_DAC_LEFT_HIGH    (1 << 3)
+#define AD193X_DAC_BCLK_INV     (1 << 7)
+#define AD193X_DAC_FMT_MASK	(AD193X_DAC_LCR_MASTER | \
+	AD193X_DAC_BCLK_MASTER | AD193X_DAC_LEFT_HIGH | AD193X_DAC_BCLK_INV)
+#define AD193X_DAC_CTRL2        0x04
+#define AD193X_DAC_WORD_LEN_SHFT        3
+#define AD193X_DAC_WORD_LEN_MASK        0x18
+#define AD193X_DAC_MASTER_MUTE  1
+#define AD193X_DAC_CHNL_MUTE    0x05
+#define AD193X_DACL1_MUTE       0
+#define AD193X_DACR1_MUTE       1
+#define AD193X_DACL2_MUTE       2
+#define AD193X_DACR2_MUTE       3
+#define AD193X_DACL3_MUTE       4
+#define AD193X_DACR3_MUTE       5
+#define AD193X_DACL4_MUTE       6
+#define AD193X_DACR4_MUTE       7
+#define AD193X_DAC_L1_VOL       0x06
+#define AD193X_DAC_R1_VOL       0x07
+#define AD193X_DAC_L2_VOL       0x08
+#define AD193X_DAC_R2_VOL       0x09
+#define AD193X_DAC_L3_VOL       0x0a
+#define AD193X_DAC_R3_VOL       0x0b
+#define AD193X_DAC_L4_VOL       0x0c
+#define AD193X_DAC_R4_VOL       0x0d
+#define AD193X_ADC_CTRL0        0x0e
+#define AD193X_ADC_POWERDOWN           0x01
+#define AD193X_ADC_HIGHPASS_FILTER	1
+#define AD193X_ADCL1_MUTE 		2
+#define AD193X_ADCR1_MUTE 		3
+#define AD193X_ADCL2_MUTE 		4
+#define AD193X_ADCR2_MUTE 		5
+#define AD193X_ADC_CTRL1        0x0f
+#define AD193X_ADC_SERFMT_MASK		0x60
+#define AD193X_ADC_SERFMT_STEREO	(0 << 5)
+#define AD193X_ADC_SERFMT_TDM		(1 << 5)
+#define AD193X_ADC_SERFMT_AUX		(2 << 5)
+#define AD193X_ADC_WORD_LEN_MASK	0x3
+#define AD193X_ADC_CTRL2        0x10
+#define AD193X_ADC_CHAN_SHFT    4
+#define AD193X_ADC_CHAN_MASK    (3 << AD193X_ADC_CHAN_SHFT)
+#define AD193X_ADC_LCR_MASTER   (1 << 3)
+#define AD193X_ADC_BCLK_MASTER  (1 << 6)
+#define AD193X_ADC_LEFT_HIGH    (1 << 2)
+#define AD193X_ADC_BCLK_INV     (1 << 1)
+#define AD193X_ADC_FMT_MASK	(AD193X_ADC_LCR_MASTER | \
+	AD193X_ADC_BCLK_MASTER | AD193X_ADC_LEFT_HIGH | AD193X_ADC_BCLK_INV)
+
+#define AD193X_2_CHANNELS   0
+#define AD193X_4_CHANNELS   1
+#define AD193X_8_CHANNELS   2
+#define AD193X_16_CHANNELS  3
+
+#define AD193X_NUM_REGS          17
+
+#define AD193X_SYSCLK_PLL	0
+#define AD193X_SYSCLK_MCLK	1
+
+#endif */
+
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * AD193X Audio Codec driver
+ *
+ * Copyright 2010 Analog Devices Inc.
+ */
+
+#ifndef __AD193X_H__
+#define __AD193X_H__
+
+#include <linux/regmap.h>
+
+struct device;
+
+enum ad193x_type {
+	AD193X,
+	AD1933,
+	AD1934,
+};
+
+extern const struct regmap_config ad193x_regmap_config;
+int ad193x_probe(struct device *dev, struct regmap *regmap,
+		 enum ad193x_type type);
+
+#define AD193X_PLL_CLK_CTRL0    	0x00
+#define AD193X_PLL_POWERDOWN        0x01
+#define AD193X_PLL_INPUT_MASK   	0x6
+#define AD193X_PLL_INPUT_256    	(0 << 1)
+#define AD193X_PLL_INPUT_384    	(1 << 1)
+#define AD193X_PLL_INPUT_512    	(2 << 1)
+#define AD193X_PLL_INPUT_768    	(3 << 1)
+#define AD193X_PLL_MCLKXO_MASK   	0x18
+#define AD193X_PLL_X0_XTAL	    	(0 << 3)
+#define AD193X_PLL_X0_256VCO    	(1 << 3)
+#define AD193X_PLL_X0_512VCO    	(2 << 3)
+#define AD193X_PLL_X0_OFF	    	(3 << 3)
+#define AD193X_PLL_SOURCE_MASK  	0x60
+#define AD193X_PLL_SOURCE_MCLKXI   	(0 << 5)
+#define AD193X_PLL_SOURCE_DLRCLK   	(1 << 5)
+#define AD193X_PLL_SOURCE_ALRCLK   	(2 << 5)
+
+
+
+
 
+#define AD193X_PLL_CLK_CTRL1    0x01
+#define AD193X_PLL_SRC_MASK	0x03
+#define AD193X_PLL_DAC_SRC_PLL  0
+#define AD193X_PLL_DAC_SRC_MCLK 1
+#define AD193X_PLL_ADC_SRC_PLL  (0 << 1)
+#define AD193X_PLL_ADC_SRC_MCLK	(1 << 1)
+#define AD193X_DAC_CTRL0        0x02
+#define AD193X_DAC_POWERDOWN           0x01
+#define AD193X_DAC_SERFMT_MASK		0xC0
+#define AD193X_DAC_SERFMT_STEREO	(0 << 6)
+#define AD193X_DAC_SERFMT_TDM		(1 << 6)
 #define AD193X_DAC_CTRL1        0x03
 #define AD193X_DAC_CHAN_SHFT    1
 #define AD193X_DAC_CHAN_MASK    (3 << AD193X_DAC_CHAN_SHFT)
@@ -121,4 +236,13 @@ int ad193x_probe(struct device *dev, struct regmap *regmap,
 #define AD193X_SYSCLK_PLL	0
 #define AD193X_SYSCLK_MCLK	1
 
+#define AD193X_PLL_ID		0
+
+#define AD193X_PLL_INPUT_ALRCLK 	0x00
+#define AD193X_PLL_INPUT_DLRCLK 	0x01
+#define AD193X_PLL_INPUT_MCLK 		0x02
+#define AD193X_PLL_INPUT_XTAL 		0x03
+
+
+
 #endif
diff --git a/sound/soc/stm/stm32_ad1938.c b/sound/soc/stm/stm32_ad1938.c
index 3a3a1ae7a..27988118e 100644
--- a/sound/soc/stm/stm32_ad1938.c
+++ b/sound/soc/stm/stm32_ad1938.c
@@ -20,45 +20,38 @@
 static const struct snd_soc_dapm_widget stm_asoc_ad1938_dapm_widgets[] = {
 	SND_SOC_DAPM_LINE("Line In Jack 1", NULL),
 	SND_SOC_DAPM_LINE("Line In Jack 2", NULL),
-	SND_SOC_DAPM_HP("Line Out Jack 1", NULL),
-	SND_SOC_DAPM_HP("Line Out Jack 2", NULL),	
+	SND_SOC_DAPM_LINE("Line Out Jack 1", NULL),
+	SND_SOC_DAPM_LINE("Line Out Jack 2", NULL),	
+	SND_SOC_DAPM_HP("Headphones Left", NULL),
+	SND_SOC_DAPM_HP("Headphones Right", NULL),
 };
 
 static int stm_asoc_ad1938_hw_params(struct snd_pcm_substream *substream,
 		struct snd_pcm_hw_params *params)
 {
-//	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-//	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-//	struct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);
-//	struct platform_device *pdev_sync_provider = of_find_device_by_node(sai->np_sync_provider_sai_sub);
-//	struct stm32_sai_sub_data *sai_provider = platform_get_drvdata(pdev_sync_provider);
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai =  rtd->codec_dai;	
+	int ret;
+
+	ret = snd_soc_dai_set_pll(codec_dai, AD193X_PLL_ID, AD193X_PLL_INPUT_DLRCLK,
+		params_rate(params), 0);
+		if (ret < 0) {
+		pr_err("%s - failed to set AD1938 codec PLL.", __func__);
+		return ret;
+	}
 
+	/*
+	 * As here AD1938 use pLL output as its system clock
+	 * so calling set_sysclk won't care freq parameter
+	 * then we pass 0
+	 */
+	ret = snd_soc_dai_set_sysclk(codec_dai, AD193X_SYSCLK_PLL,
+			0, SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		pr_err("%s -failed to set AD1938 SYSCLK\n", __func__);
+		return ret;
+	}
 	
-//	int ret;
-//
-//	/*MD: These functions to setup codec. Depends on the function which are
-//	defined in the codec driver, under snd_soc_dai_ops (I believe)
-//	*/
-//	ret = snd_soc_dai_set_pll(codec_dai, WM8904_FLL_MCLK, WM8904_FLL_MCLK,
-//		32768, params_rate(params) * 256);
-//	if (ret < 0) {
-//		pr_err("%s - failed to set wm8904 codec PLL.", __func__);
-//		return ret;
-//	}
-//
-//	/*
-//	 * As here wm8904 use FLL output as its system clock
-//	 * so calling set_sysclk won't care freq parameter
-//	 * then we pass 0
-//	 */
-//	ret = snd_soc_dai_set_sysclk(codec_dai, WM8904_CLK_FLL,
-//			0, SND_SOC_CLOCK_IN);
-//	if (ret < 0) {
-//		pr_err("%s -failed to set wm8904 SYSCLK\n", __func__);
-//		return ret;
-//	}
-//
-printk(" MACHINE HW PARAM ");
 	return 0;
 }
 
@@ -76,7 +69,6 @@ SND_SOC_DAILINK_DEFS(pcm2,
 	DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "ad193x-hifi")),
 	DAILINK_COMP_ARRAY(COMP_EMPTY()));
 
-/* Slide 8 */
 static struct snd_soc_dai_link stm_asoc_ad1938_dailink[] = {
 	{
 	.name = "ad1938_1",
@@ -98,7 +90,6 @@ static struct snd_soc_dai_link stm_asoc_ad1938_dailink[] = {
 	}		
 };
 
-/* Slide 7 */
 static struct snd_soc_card stm_asoc_ad1938_card = {
 	.name = "stm_asoc_ad1938",
 	.owner = THIS_MODULE,
@@ -174,15 +165,12 @@ static int stm_asoc_ad1938_dt_init(struct platform_device *pdev)
 	}
 	dailink2->codecs->of_node = codec_np;
 	of_node_put(codec_np);
-
-
 	return 0;
 }
 
 static int stm_asoc_ad1938_probe(struct platform_device *pdev)
 {
 	struct snd_soc_card *card = &stm_asoc_ad1938_card;
-	//struct snd_soc_dai_link *dailink = &stm_asoc_ad1938_dailink;
 	int id, ret;
 
 	card->dev = &pdev->dev;
@@ -192,37 +180,22 @@ static int stm_asoc_ad1938_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	/*id = of_alias_get_id((struct device_node *)dailink->cpus->of_node, "ssc");
-	ret = atmel_ssc_set_audio(id);
-	if (ret != 0) {
-		dev_err(&pdev->dev, "failed to set SSC %d for audio\n", id);
-		return ret;
-	}*/ /*MD: ??? */
-
 	ret = snd_soc_register_card(card);
 	if (ret) {
 		dev_err(&pdev->dev, "snd_soc_register_card failed\n");
-		goto err_set_audio;
+		return ret;
 	}
 
 	return 0;
-
-err_set_audio:
-	//atmel_ssc_put_audio(id);
-	return ret;
 }
 
 static int stm_asoc_1938_remove(struct platform_device *pdev)
 {
 	struct snd_soc_card *card = platform_get_drvdata(pdev);
-//	struct snd_soc_dai_link *dailink = &stm_asoc_ad1938_dailink;
 	int id;
 
-	//id = of_alias_get_id((struct device_node *)dailink->cpus->of_node, "ssc");
-
 	snd_soc_unregister_card(card);
-	//atmel_ssc_put_audio(id);
-
+	
 	return 0;
 }
 
-- 
2.17.1


From d13905e037e61ba139d832ec1c2bedb4eba63e2b Mon Sep 17 00:00:00 2001
From: P3NN4 <teodaria@gmail.com>
Date: Sat, 17 Oct 2020 18:17:25 -0400
Subject: [PATCH 3/5] Remove debug output

---
 sound/soc/codecs/ad193x.c | 10 ----------
 1 file changed, 10 deletions(-)

diff --git a/sound/soc/codecs/ad193x.c b/sound/soc/codecs/ad193x.c
index 4ad4022b8..dfdaf3780 100644
--- a/sound/soc/codecs/ad193x.c
+++ b/sound/soc/codecs/ad193x.c
@@ -146,8 +146,6 @@ static inline bool ad193x_has_adc(const struct ad193x_priv *ad193x)
 
 static int ad193x_mute(struct snd_soc_dai *dai, int mute)
 {
-				printk(" test ad1938 component ad193x_mute %d", mute);
-
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(dai->component);
 
 	if (mute)
@@ -164,8 +162,6 @@ static int ad193x_mute(struct snd_soc_dai *dai, int mute)
 static int ad193x_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 			       unsigned int rx_mask, int slots, int width)
 {
-			printk(" test ad1938 component ad193x_set_tdm_slot");
-
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(dai->component);
 	unsigned int channels;
 
@@ -199,9 +195,6 @@ static int ad193x_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 static int ad193x_set_dai_fmt(struct snd_soc_dai *codec_dai,
 		unsigned int fmt)
 {
-		printk(" test ad1938 component ad193x_set_dai_fmt");
-	return 0;
-
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(codec_dai->component);
 	unsigned int adc_serfmt = 0;
 	unsigned int dac_serfmt = 0;
@@ -289,7 +282,6 @@ static int ad193x_set_dai_fmt(struct snd_soc_dai *codec_dai,
 static int ad193x_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 		int clk_id, unsigned int freq, int dir)
 {
-
 	struct snd_soc_component *component = codec_dai->component;
 	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
@@ -470,8 +462,6 @@ static int ad193x_hw_params(struct snd_pcm_substream *substream,
 static int ad193x_startup(struct snd_pcm_substream *substream,
 			  struct snd_soc_dai *dai)
 {
-	printk("test ad1938 component ad193x_startup");
-
 	return snd_pcm_hw_constraint_list(substream->runtime, 0,
 				   SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
 				   &constr);
-- 
2.17.1


From 5f1a8f1b4a19d8e08e0dd04c7b3c3b7981d97bca Mon Sep 17 00:00:00 2001
From: P3NN4 <teodaria@gmail.com>
Date: Sun, 18 Oct 2020 07:33:29 -0400
Subject: [PATCH 4/5] Removed wrong returns

---
 sound/soc/codecs/ad193x.c | 9 +--------
 1 file changed, 1 insertion(+), 8 deletions(-)

diff --git a/sound/soc/codecs/ad193x.c b/sound/soc/codecs/ad193x.c
index dfdaf3780..91afa381d 100644
--- a/sound/soc/codecs/ad193x.c
+++ b/sound/soc/codecs/ad193x.c
@@ -285,7 +285,6 @@ static int ad193x_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 	struct snd_soc_component *component = codec_dai->component;
 	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
-		printk(" test ad1938 component ad193x_set_dai_sysclk");
 
 	if (clk_id == AD193X_SYSCLK_MCLK) {
 		/* MCLK must be 512 x fs */
@@ -325,11 +324,6 @@ static int ad193x_set_pll(struct snd_soc_dai *codec_dai, int pll_id, int source,
 	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
 	
-		printk("test ad193x_set_pll freq in: %d", freq_in);
-			printk("test ad193x_set_pll freq out: %d", freq_out);
-			printk("test ad193x_set_pll id  : %d", pll_id);
-			printk("test ad193x_set_pll source: %d", source);
-	
 	int master_rate;
 	
 	if (pll_id != AD193X_PLL_ID)
@@ -402,7 +396,7 @@ static int ad193x_set_pll(struct snd_soc_dai *codec_dai, int pll_id, int source,
 		break;
 	}
 
-    snd_soc_dapm_sync(dapm); // ?
+    snd_soc_dapm_sync(dapm); 
 	return 0;
 
 }
@@ -411,7 +405,6 @@ static int ad193x_hw_params(struct snd_pcm_substream *substream,
 		struct snd_pcm_hw_params *params,
 		struct snd_soc_dai *dai)
 {
-	return 0;
 	int word_len = 0, master_rate = 0;
 	struct snd_soc_component *component = dai->component;
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
-- 
2.17.1


From 62e9c8d512c3f531ec7cbb4204841036175f3575 Mon Sep 17 00:00:00 2001
From: P3NN4 <teodaria@gmail.com>
Date: Sun, 18 Oct 2020 13:36:41 -0400
Subject: [PATCH 5/5] removed headphones support

---
 arch/arm/boot/dts/stm32mp15xx-dkx.dtsi | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
index a0eb97108..7bef984cc 100644
--- a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
@@ -72,8 +72,8 @@
 		stm,audio-routing =		
 			"Line Out Jack 1" , "DAC1OUT",
 			"Line Out Jack 2" , "DAC2OUT",
-			"Headphones Left" , "DAC3OUT",
-			"Headphones Right" , "DAC4OUT",
+			//"Headphones Left" , "DAC3OUT",
+			//"Headphones Right" , "DAC4OUT",
 			"ADC1IN" , "Line In Jack 1",
 			"ADC2IN" , "Line In Jack 2";
 		stm,sai-controller = <&sai2a &sai2b>;
-- 
2.17.1

