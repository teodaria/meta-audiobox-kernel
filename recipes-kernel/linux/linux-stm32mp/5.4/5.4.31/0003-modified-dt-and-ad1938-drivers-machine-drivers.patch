From 2bd6a020dac747c05927eaf2f07d27382ebc927a Mon Sep 17 00:00:00 2001
From: P3NN4 <teodaria@gmail.com>
Date: Tue, 1 Sep 2020 17:39:27 -0400
Subject: [PATCH 3/3] modified dt and ad1938 drivers + machine drivers

---
 arch/arm/boot/dts/stm32mp15xx-dkx.dtsi |   6 +-
 sound/soc/codecs/ad193x.c              | 187 ++++++++++++++++---------
 sound/soc/codecs/ad193x.h              | 136 +++++++++++++++++-
 sound/soc/stm/stm32_ad1938.c           |  81 ++++-------
 4 files changed, 286 insertions(+), 124 deletions(-)

diff --git a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
index 2ba556d8f..a0eb97108 100644
--- a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
@@ -71,7 +71,11 @@
 		stm,model = "ad1938 expansion card";
 		stm,audio-routing =		
 			"Line Out Jack 1" , "DAC1OUT",
-		"	ADC1IN" , "Line In Jack 1";
+			"Line Out Jack 2" , "DAC2OUT",
+			"Headphones Left" , "DAC3OUT",
+			"Headphones Right" , "DAC4OUT",
+			"ADC1IN" , "Line In Jack 1",
+			"ADC2IN" , "Line In Jack 2";
 		stm,sai-controller = <&sai2a &sai2b>;
 		stm,audio-codec = <&ad1938 &ad1938>;
 	};
diff --git a/sound/soc/codecs/ad193x.c b/sound/soc/codecs/ad193x.c
index b77d9b12f..4ad4022b8 100644
--- a/sound/soc/codecs/ad193x.c
+++ b/sound/soc/codecs/ad193x.c
@@ -84,7 +84,7 @@ static const struct snd_kcontrol_new ad193x_adc_snd_controls[] = {
 static const struct snd_soc_dapm_widget ad193x_dapm_widgets[] = {
 	SND_SOC_DAPM_DAC("DAC", "Playback", SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_PGA("DAC Output", AD193X_DAC_CTRL0, 0, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("PLL_PWR", AD193X_PLL_CLK_CTRL0, 0, 0, NULL, 0),//MD
+	SND_SOC_DAPM_SUPPLY("PLL_PWR", AD193X_PLL_CLK_CTRL0, 0, 1, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("SYSCLK", AD193X_PLL_CLK_CTRL0, 7, 0, NULL, 0),
 	SND_SOC_DAPM_VMID("VMID"),
 	SND_SOC_DAPM_OUTPUT("DAC1OUT"),
@@ -106,7 +106,7 @@ static int ad193x_check_pll(struct snd_soc_dapm_widget *source,
 	struct snd_soc_component *component = snd_soc_dapm_to_component(source->dapm);
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
 
-	return !!ad193x->sysclk;
+	return !ad193x->sysclk;
 }
 
 static const struct snd_soc_dapm_route audio_paths[] = {
@@ -146,7 +146,7 @@ static inline bool ad193x_has_adc(const struct ad193x_priv *ad193x)
 
 static int ad193x_mute(struct snd_soc_dai *dai, int mute)
 {
-				printk(" test ad1938 component ad193x_mute");
+				printk(" test ad1938 component ad193x_mute %d", mute);
 
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(dai->component);
 
@@ -289,57 +289,128 @@ static int ad193x_set_dai_fmt(struct snd_soc_dai *codec_dai,
 static int ad193x_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 		int clk_id, unsigned int freq, int dir)
 {
-	printk(" test ad1938 component ad193x_set_dai_sysclk");
-
-//	struct snd_soc_component *component = codec_dai->component;
-//	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
-//	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
-//
-//	if (clk_id == AD193X_SYSCLK_MCLK) {
-//		/* MCLK must be 512 x fs */
-//		if (dir == SND_SOC_CLOCK_OUT || freq != 24576000)
-//			return -EINVAL;
-//
-//		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
-//				   AD193X_PLL_SRC_MASK,
-//				   AD193X_PLL_DAC_SRC_MCLK |
-//				   AD193X_PLL_CLK_SRC_MCLK);
-//
-//		snd_soc_dapm_sync(dapm);
-//		return 0;
-//	}
-//	
-//	switch (freq) {
-//	case 12288000:
-//	case 18432000:
-//	case 24576000:
-//	case 36864000:
-//		ad193x->sysclk = freq;
-//		return 0;
-//	}
-//	return -EINVAL;
-	return 0;
+
+	struct snd_soc_component *component = codec_dai->component;
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
+		printk(" test ad1938 component ad193x_set_dai_sysclk");
+
+	if (clk_id == AD193X_SYSCLK_MCLK) {
+		/* MCLK must be 512 x fs */
+		if (dir == SND_SOC_CLOCK_OUT || freq != 24576000)
+			return -EINVAL;
+
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
+				   AD193X_PLL_SRC_MASK,
+				   AD193X_PLL_DAC_SRC_MCLK |
+				   AD193X_PLL_ADC_SRC_MCLK);
+
+		snd_soc_dapm_sync(dapm);
+		ad193x->sysclk = freq;
+		return 0;
+	}
+	else if (clk_id == AD193X_SYSCLK_PLL) {
+		
+		if (dir != SND_SOC_CLOCK_IN)
+			return -EINVAL;
+		
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
+				  AD193X_PLL_SRC_MASK,
+				  AD193X_PLL_DAC_SRC_PLL |
+				  AD193X_PLL_ADC_SRC_PLL);
+		snd_soc_dapm_sync(dapm);		
+		return 0;	
+	}
+
+	return -EINVAL;
+
 }
 
 static int ad193x_set_pll(struct snd_soc_dai *codec_dai, int pll_id, int source,
 		unsigned int freq_in, unsigned int freq_out)
 {
-//	struct snd_soc_component *component = codec_dai->component;
-//	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
-//	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
-//	
-//	
-//	
-//			regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
-//				   AD193X_PLL_SRC_MASK,
-//				   AD193X_PLL_DAC_SRC_MCLK |
-//				   AD193X_PLL_CLK_SRC_MCLK);
-//
-//		snd_soc_dapm_sync(dapm);
-//	
-//	
-//   return -EINVAL;
+	struct snd_soc_component *component = codec_dai->component;
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
+	
+		printk("test ad193x_set_pll freq in: %d", freq_in);
+			printk("test ad193x_set_pll freq out: %d", freq_out);
+			printk("test ad193x_set_pll id  : %d", pll_id);
+			printk("test ad193x_set_pll source: %d", source);
+	
+	int master_rate;
+	
+	if (pll_id != AD193X_PLL_ID)
+			return -EINVAL;	
+	
+	switch (freq_in) {
+	case 12288000:
+		master_rate = AD193X_PLL_INPUT_256;
+		break;
+	case 18432000:
+		master_rate = AD193X_PLL_INPUT_384;
+		break;
+	case 24576000:
+		master_rate = AD193X_PLL_INPUT_512;
+		break;
+	case 36864000:
+		master_rate = AD193X_PLL_INPUT_768;
+		break;
+	default:
+		master_rate = 0;
+		break;
+	}
+
+	
+	if (freq_out != AD193X_PLL_X0_256VCO && freq_out != AD193X_PLL_X0_512VCO && freq_out != 0)
+		/* error if OUT not supported */
+		return -EINVAL; 	
 	
+	switch (source) {
+		case AD193X_PLL_INPUT_XTAL:
+			if (freq_out != 0)
+				/* If XTAL, XO is used, no output possible */
+				return -EINVAL; 
+		/* Set input ratio */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+			   AD193X_PLL_INPUT_MASK, master_rate);
+		/* Activate oscillator */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+			   AD193X_PLL_MCLKXO_MASK, AD193X_PLL_X0_XTAL);
+		/* choose XI as PLL input */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+			   AD193X_PLL_SOURCE_MASK, AD193X_PLL_SOURCE_MCLKXI);	
+		break;
+	case AD193X_PLL_INPUT_MCLK:
+		/* Set input ratio */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+			   AD193X_PLL_INPUT_MASK, master_rate);
+		/* Set output */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_MCLKXO_MASK, freq_out);	
+		/* choose MCLK as PLL input */			
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_SOURCE_MASK, AD193X_PLL_SOURCE_MCLKXI);				
+		break;
+	case AD193X_PLL_INPUT_DLRCLK:
+		/* Set output */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_MCLKXO_MASK, freq_out);
+		/* choose DLRCLK as PLL input */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_SOURCE_MASK, AD193X_PLL_SOURCE_DLRCLK );			
+		break;			
+	case AD193X_PLL_INPUT_ALRCLK:
+			/* Set output */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_MCLKXO_MASK, freq_out);
+		/* choose ALRCLK as PLL input */
+		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+		    AD193X_PLL_SOURCE_MASK, AD193X_PLL_SOURCE_ALRCLK );	
+		break;
+	}
+
+    snd_soc_dapm_sync(dapm); // ?
 	return 0;
 
 }
@@ -392,7 +463,7 @@ static int ad193x_hw_params(struct snd_pcm_substream *substream,
 	if (ad193x_has_adc(ad193x))
 		regmap_update_bits(ad193x->regmap, AD193X_ADC_CTRL1,
 				   AD193X_ADC_WORD_LEN_MASK, word_len);
-printk(" test ad1938 component ad193x_hw_params");
+	
 	return 0;
 }
 
@@ -456,11 +527,11 @@ static struct snd_soc_dai_driver ad193x_no_adc_dai = {
 static void ad193x_reg_default_init(struct ad193x_priv *ad193x)
 {
 	static const struct reg_sequence reg_init[] = {
-		{  0, 0xD8 },	/* PLL_CLK_CTRL0: pll input: mclki/xi 12.288Mhz */ /*0b10100000*/
-		{  1, 0x04 },	/* PLL_CLK_CTRL1: no on-chip Vref */ /*0b00000100*/
-		{  2, 0x00 },	/* DAC_CTRL0: TDM mode */ /*0x40*/ /*0b00000000*/
+		{  0, 0x99 },	/* PLL_CLK_CTRL0: pll input: mclki/xi 12.288Mhz */
+		{  1, 0x04 },	/* PLL_CLK_CTRL1: no on-chip Vref */
+		{  2, 0x40 },	/* DAC_CTRL0: TDM mode */
 		{  3, 0x00 },	/* DAC_CTRL1: reset */
-		{  4, 0x1A },	/* DAC_CTRL2: 48kHz de-emphasis, unmute dac */ /*0b00000010*/
+		{  4, 0x1A },	/* DAC_CTRL2: 48kHz de-emphasis, unmute dac */
 		{  5, 0x00 },	/* DAC_CHNL_MUTE: unmute DAC channels */
 		{  6, 0x00 },	/* DAC_L1_VOL: no attenuation */
 		{  7, 0x00 },	/* DAC_R1_VOL: no attenuation */
@@ -526,13 +597,6 @@ static int ad193x_component_probe(struct snd_soc_component *component)
 	return 0;
 }
 
-///*static int ad193x_of_xlate_dai_id(struct snd_soc_component *component,
-//				   struct device_node *endpoint)
-//{
-//	/* return dai id 0, whatever the endpoint index */
-//	return 0;
-//}*/
-//
 static const struct snd_soc_component_driver soc_component_dev_ad193x = {
 	.probe			= ad193x_component_probe,
 	.controls		= ad193x_snd_controls,
@@ -541,15 +605,12 @@ static const struct snd_soc_component_driver soc_component_dev_ad193x = {
 	.num_dapm_widgets	= ARRAY_SIZE(ad193x_dapm_widgets),
 	.dapm_routes		= audio_paths,
 	.num_dapm_routes	= ARRAY_SIZE(audio_paths),
-//	.of_xlate_dai_id	= ad193x_of_xlate_dai_id,
 	.idle_bias_on		= 1,
 	.use_pmdown_time	= 1,
 	.endianness		= 1,
 	.non_legacy_dai_naming	= 1,
 };
 
-
-
 const struct regmap_config ad193x_regmap_config = {
 	.max_register = AD193X_NUM_REGS - 1,
 };
diff --git a/sound/soc/codecs/ad193x.h b/sound/soc/codecs/ad193x.h
index 7ef7fa93d..9cbcabbe3 100644
--- a/sound/soc/codecs/ad193x.h
+++ b/sound/soc/codecs/ad193x.h
@@ -5,7 +5,7 @@
  * Copyright 2010 Analog Devices Inc.
  */
 
-#ifndef __AD193X_H__
+/*#ifndef __AD193X_H__
 #define __AD193X_H__
 
 #include <linux/regmap.h>
@@ -23,7 +23,6 @@ int ad193x_probe(struct device *dev, struct regmap *regmap,
 		 enum ad193x_type type);
 
 #define AD193X_PLL_CLK_CTRL0    0x00
-
 #define AD193X_PLL_POWERDOWN    0x01
 #define AD193X_PLL_INPUT_MASK   0x6
 #define AD193X_PLL_INPUT_256    (0 << 1)
@@ -48,16 +47,132 @@ int ad193x_probe(struct device *dev, struct regmap *regmap,
 #define AD193X_PLL_DAC_SRC_MCLK 1
 #define AD193X_PLL_ADC_SRC_PLL  (0 << 1)
 #define AD193X_PLL_ADC_SRC_MCLK	(1 << 1)
-#define AD193X_PLL_SRC_MASK		0x04
-#define AD193X_PLL_VREF_ENABLE  (1 << 2)
-
 #define AD193X_DAC_CTRL0        0x02
-
 #define AD193X_DAC_POWERDOWN        0x01
 #define AD193X_DAC_SERFMT_MASK		0xC0
 #define AD193X_DAC_SERFMT_STEREO	(0 << 6)
 #define AD193X_DAC_SERFMT_TDM		(1 << 6)
+#define AD193X_DAC_CTRL1        0x03
+#define AD193X_DAC_CHAN_SHFT    1
+#define AD193X_DAC_CHAN_MASK    (3 << AD193X_DAC_CHAN_SHFT)
+#define AD193X_DAC_LCR_MASTER   (1 << 4)
+#define AD193X_DAC_BCLK_MASTER  (1 << 5)
+#define AD193X_DAC_LEFT_HIGH    (1 << 3)
+#define AD193X_DAC_BCLK_INV     (1 << 7)
+#define AD193X_DAC_FMT_MASK	(AD193X_DAC_LCR_MASTER | \
+	AD193X_DAC_BCLK_MASTER | AD193X_DAC_LEFT_HIGH | AD193X_DAC_BCLK_INV)
+#define AD193X_DAC_CTRL2        0x04
+#define AD193X_DAC_WORD_LEN_SHFT        3
+#define AD193X_DAC_WORD_LEN_MASK        0x18
+#define AD193X_DAC_MASTER_MUTE  1
+#define AD193X_DAC_CHNL_MUTE    0x05
+#define AD193X_DACL1_MUTE       0
+#define AD193X_DACR1_MUTE       1
+#define AD193X_DACL2_MUTE       2
+#define AD193X_DACR2_MUTE       3
+#define AD193X_DACL3_MUTE       4
+#define AD193X_DACR3_MUTE       5
+#define AD193X_DACL4_MUTE       6
+#define AD193X_DACR4_MUTE       7
+#define AD193X_DAC_L1_VOL       0x06
+#define AD193X_DAC_R1_VOL       0x07
+#define AD193X_DAC_L2_VOL       0x08
+#define AD193X_DAC_R2_VOL       0x09
+#define AD193X_DAC_L3_VOL       0x0a
+#define AD193X_DAC_R3_VOL       0x0b
+#define AD193X_DAC_L4_VOL       0x0c
+#define AD193X_DAC_R4_VOL       0x0d
+#define AD193X_ADC_CTRL0        0x0e
+#define AD193X_ADC_POWERDOWN           0x01
+#define AD193X_ADC_HIGHPASS_FILTER	1
+#define AD193X_ADCL1_MUTE 		2
+#define AD193X_ADCR1_MUTE 		3
+#define AD193X_ADCL2_MUTE 		4
+#define AD193X_ADCR2_MUTE 		5
+#define AD193X_ADC_CTRL1        0x0f
+#define AD193X_ADC_SERFMT_MASK		0x60
+#define AD193X_ADC_SERFMT_STEREO	(0 << 5)
+#define AD193X_ADC_SERFMT_TDM		(1 << 5)
+#define AD193X_ADC_SERFMT_AUX		(2 << 5)
+#define AD193X_ADC_WORD_LEN_MASK	0x3
+#define AD193X_ADC_CTRL2        0x10
+#define AD193X_ADC_CHAN_SHFT    4
+#define AD193X_ADC_CHAN_MASK    (3 << AD193X_ADC_CHAN_SHFT)
+#define AD193X_ADC_LCR_MASTER   (1 << 3)
+#define AD193X_ADC_BCLK_MASTER  (1 << 6)
+#define AD193X_ADC_LEFT_HIGH    (1 << 2)
+#define AD193X_ADC_BCLK_INV     (1 << 1)
+#define AD193X_ADC_FMT_MASK	(AD193X_ADC_LCR_MASTER | \
+	AD193X_ADC_BCLK_MASTER | AD193X_ADC_LEFT_HIGH | AD193X_ADC_BCLK_INV)
+
+#define AD193X_2_CHANNELS   0
+#define AD193X_4_CHANNELS   1
+#define AD193X_8_CHANNELS   2
+#define AD193X_16_CHANNELS  3
+
+#define AD193X_NUM_REGS          17
+
+#define AD193X_SYSCLK_PLL	0
+#define AD193X_SYSCLK_MCLK	1
+
+#endif */
+
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * AD193X Audio Codec driver
+ *
+ * Copyright 2010 Analog Devices Inc.
+ */
+
+#ifndef __AD193X_H__
+#define __AD193X_H__
+
+#include <linux/regmap.h>
+
+struct device;
+
+enum ad193x_type {
+	AD193X,
+	AD1933,
+	AD1934,
+};
+
+extern const struct regmap_config ad193x_regmap_config;
+int ad193x_probe(struct device *dev, struct regmap *regmap,
+		 enum ad193x_type type);
+
+#define AD193X_PLL_CLK_CTRL0    	0x00
+#define AD193X_PLL_POWERDOWN        0x01
+#define AD193X_PLL_INPUT_MASK   	0x6
+#define AD193X_PLL_INPUT_256    	(0 << 1)
+#define AD193X_PLL_INPUT_384    	(1 << 1)
+#define AD193X_PLL_INPUT_512    	(2 << 1)
+#define AD193X_PLL_INPUT_768    	(3 << 1)
+#define AD193X_PLL_MCLKXO_MASK   	0x18
+#define AD193X_PLL_X0_XTAL	    	(0 << 3)
+#define AD193X_PLL_X0_256VCO    	(1 << 3)
+#define AD193X_PLL_X0_512VCO    	(2 << 3)
+#define AD193X_PLL_X0_OFF	    	(3 << 3)
+#define AD193X_PLL_SOURCE_MASK  	0x60
+#define AD193X_PLL_SOURCE_MCLKXI   	(0 << 5)
+#define AD193X_PLL_SOURCE_DLRCLK   	(1 << 5)
+#define AD193X_PLL_SOURCE_ALRCLK   	(2 << 5)
+
+
+
+
 
+#define AD193X_PLL_CLK_CTRL1    0x01
+#define AD193X_PLL_SRC_MASK	0x03
+#define AD193X_PLL_DAC_SRC_PLL  0
+#define AD193X_PLL_DAC_SRC_MCLK 1
+#define AD193X_PLL_ADC_SRC_PLL  (0 << 1)
+#define AD193X_PLL_ADC_SRC_MCLK	(1 << 1)
+#define AD193X_DAC_CTRL0        0x02
+#define AD193X_DAC_POWERDOWN           0x01
+#define AD193X_DAC_SERFMT_MASK		0xC0
+#define AD193X_DAC_SERFMT_STEREO	(0 << 6)
+#define AD193X_DAC_SERFMT_TDM		(1 << 6)
 #define AD193X_DAC_CTRL1        0x03
 #define AD193X_DAC_CHAN_SHFT    1
 #define AD193X_DAC_CHAN_MASK    (3 << AD193X_DAC_CHAN_SHFT)
@@ -121,4 +236,13 @@ int ad193x_probe(struct device *dev, struct regmap *regmap,
 #define AD193X_SYSCLK_PLL	0
 #define AD193X_SYSCLK_MCLK	1
 
+#define AD193X_PLL_ID		0
+
+#define AD193X_PLL_INPUT_ALRCLK 	0x00
+#define AD193X_PLL_INPUT_DLRCLK 	0x01
+#define AD193X_PLL_INPUT_MCLK 		0x02
+#define AD193X_PLL_INPUT_XTAL 		0x03
+
+
+
 #endif
diff --git a/sound/soc/stm/stm32_ad1938.c b/sound/soc/stm/stm32_ad1938.c
index 3a3a1ae7a..27988118e 100644
--- a/sound/soc/stm/stm32_ad1938.c
+++ b/sound/soc/stm/stm32_ad1938.c
@@ -20,45 +20,38 @@
 static const struct snd_soc_dapm_widget stm_asoc_ad1938_dapm_widgets[] = {
 	SND_SOC_DAPM_LINE("Line In Jack 1", NULL),
 	SND_SOC_DAPM_LINE("Line In Jack 2", NULL),
-	SND_SOC_DAPM_HP("Line Out Jack 1", NULL),
-	SND_SOC_DAPM_HP("Line Out Jack 2", NULL),	
+	SND_SOC_DAPM_LINE("Line Out Jack 1", NULL),
+	SND_SOC_DAPM_LINE("Line Out Jack 2", NULL),	
+	SND_SOC_DAPM_HP("Headphones Left", NULL),
+	SND_SOC_DAPM_HP("Headphones Right", NULL),
 };
 
 static int stm_asoc_ad1938_hw_params(struct snd_pcm_substream *substream,
 		struct snd_pcm_hw_params *params)
 {
-//	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-//	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-//	struct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);
-//	struct platform_device *pdev_sync_provider = of_find_device_by_node(sai->np_sync_provider_sai_sub);
-//	struct stm32_sai_sub_data *sai_provider = platform_get_drvdata(pdev_sync_provider);
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai =  rtd->codec_dai;	
+	int ret;
+
+	ret = snd_soc_dai_set_pll(codec_dai, AD193X_PLL_ID, AD193X_PLL_INPUT_DLRCLK,
+		params_rate(params), 0);
+		if (ret < 0) {
+		pr_err("%s - failed to set AD1938 codec PLL.", __func__);
+		return ret;
+	}
 
+	/*
+	 * As here AD1938 use pLL output as its system clock
+	 * so calling set_sysclk won't care freq parameter
+	 * then we pass 0
+	 */
+	ret = snd_soc_dai_set_sysclk(codec_dai, AD193X_SYSCLK_PLL,
+			0, SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		pr_err("%s -failed to set AD1938 SYSCLK\n", __func__);
+		return ret;
+	}
 	
-//	int ret;
-//
-//	/*MD: These functions to setup codec. Depends on the function which are
-//	defined in the codec driver, under snd_soc_dai_ops (I believe)
-//	*/
-//	ret = snd_soc_dai_set_pll(codec_dai, WM8904_FLL_MCLK, WM8904_FLL_MCLK,
-//		32768, params_rate(params) * 256);
-//	if (ret < 0) {
-//		pr_err("%s - failed to set wm8904 codec PLL.", __func__);
-//		return ret;
-//	}
-//
-//	/*
-//	 * As here wm8904 use FLL output as its system clock
-//	 * so calling set_sysclk won't care freq parameter
-//	 * then we pass 0
-//	 */
-//	ret = snd_soc_dai_set_sysclk(codec_dai, WM8904_CLK_FLL,
-//			0, SND_SOC_CLOCK_IN);
-//	if (ret < 0) {
-//		pr_err("%s -failed to set wm8904 SYSCLK\n", __func__);
-//		return ret;
-//	}
-//
-printk(" MACHINE HW PARAM ");
 	return 0;
 }
 
@@ -76,7 +69,6 @@ SND_SOC_DAILINK_DEFS(pcm2,
 	DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "ad193x-hifi")),
 	DAILINK_COMP_ARRAY(COMP_EMPTY()));
 
-/* Slide 8 */
 static struct snd_soc_dai_link stm_asoc_ad1938_dailink[] = {
 	{
 	.name = "ad1938_1",
@@ -98,7 +90,6 @@ static struct snd_soc_dai_link stm_asoc_ad1938_dailink[] = {
 	}		
 };
 
-/* Slide 7 */
 static struct snd_soc_card stm_asoc_ad1938_card = {
 	.name = "stm_asoc_ad1938",
 	.owner = THIS_MODULE,
@@ -174,15 +165,12 @@ static int stm_asoc_ad1938_dt_init(struct platform_device *pdev)
 	}
 	dailink2->codecs->of_node = codec_np;
 	of_node_put(codec_np);
-
-
 	return 0;
 }
 
 static int stm_asoc_ad1938_probe(struct platform_device *pdev)
 {
 	struct snd_soc_card *card = &stm_asoc_ad1938_card;
-	//struct snd_soc_dai_link *dailink = &stm_asoc_ad1938_dailink;
 	int id, ret;
 
 	card->dev = &pdev->dev;
@@ -192,37 +180,22 @@ static int stm_asoc_ad1938_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	/*id = of_alias_get_id((struct device_node *)dailink->cpus->of_node, "ssc");
-	ret = atmel_ssc_set_audio(id);
-	if (ret != 0) {
-		dev_err(&pdev->dev, "failed to set SSC %d for audio\n", id);
-		return ret;
-	}*/ /*MD: ??? */
-
 	ret = snd_soc_register_card(card);
 	if (ret) {
 		dev_err(&pdev->dev, "snd_soc_register_card failed\n");
-		goto err_set_audio;
+		return ret;
 	}
 
 	return 0;
-
-err_set_audio:
-	//atmel_ssc_put_audio(id);
-	return ret;
 }
 
 static int stm_asoc_1938_remove(struct platform_device *pdev)
 {
 	struct snd_soc_card *card = platform_get_drvdata(pdev);
-//	struct snd_soc_dai_link *dailink = &stm_asoc_ad1938_dailink;
 	int id;
 
-	//id = of_alias_get_id((struct device_node *)dailink->cpus->of_node, "ssc");
-
 	snd_soc_unregister_card(card);
-	//atmel_ssc_put_audio(id);
-
+	
 	return 0;
 }
 
-- 
2.17.1

