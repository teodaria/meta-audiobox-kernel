From 4fb0d83fb9e9316da621d007dd3514d19bff8a6e Mon Sep 17 00:00:00 2001
From: P3NN4 <teodaria@gmail.com>
Date: Tue, 1 Sep 2020 08:38:30 -0400
Subject: [PATCH 2/3] initial modifications

---
 arch/arm/boot/dts/stm32mp15xx-dkx.dtsi | 104 +++++-----
 sound/soc/codecs/Kconfig               |   6 +-
 sound/soc/codecs/ad193x.c              | 119 ++++++++----
 sound/soc/codecs/ad193x.h              |  28 ++-
 sound/soc/stm/Kconfig                  |   8 +
 sound/soc/stm/Makefile                 |   5 +
 sound/soc/stm/stm32_ad1938.c           | 252 +++++++++++++++++++++++++
 7 files changed, 426 insertions(+), 96 deletions(-)
 create mode 100644 sound/soc/stm/stm32_ad1938.c

diff --git a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
index 35169385f..2ba556d8f 100644
--- a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
@@ -65,16 +65,15 @@
 			default-state = "off";
 		};
 	};
-
+	
 	sound {
-		compatible = "audio-graph-card";
-		label = "STM32MP1-DK";
-		routing =
-			"Playback" , "MCLK",
-			"Capture" , "MCLK",
-			"MICL" , "Mic Bias";
-		dais = <&sai2a_port &sai2b_port &i2s2_port>;
-		status = "okay";
+		compatible = "stm,asoc-ad1938";
+		stm,model = "ad1938 expansion card";
+		stm,audio-routing =		
+			"Line Out Jack 1" , "DAC1OUT",
+		"	ADC1IN" , "Line In Jack 1";
+		stm,sai-controller = <&sai2a &sai2b>;
+		stm,audio-codec = <&ad1938 &ad1938>;
 	};
 
 	usb_phy_tuning: usb-phy-tuning {
@@ -223,39 +222,6 @@
 			};
 		};
 	};
-
-	cs42l51: cs42l51@4a {
-		compatible = "cirrus,cs42l51";
-		reg = <0x4a>;
-		#sound-dai-cells = <0>;
-		VL-supply = <&v3v3>;
-		VD-supply = <&v1v8_audio>;
-		VA-supply = <&v1v8_audio>;
-		VAHP-supply = <&v1v8_audio>;
-		reset-gpios = <&gpiog 9 GPIO_ACTIVE_LOW>;
-		clocks = <&sai2a>;
-		clock-names = "MCLK";
-		status = "okay";
-
-		cs42l51_port: port {
-			#address-cells = <1>;
-			#size-cells = <0>;
-
-			cs42l51_tx_endpoint: endpoint@0 {
-				reg = <0>;
-				remote-endpoint = <&sai2a_endpoint>;
-				frame-master;
-				bitclock-master;
-			};
-
-			cs42l51_rx_endpoint: endpoint@1 {
-				reg = <1>;
-				remote-endpoint = <&sai2b_endpoint>;
-				frame-master;
-				bitclock-master;
-			};
-		};
-	};
 };
 
 &i2c4 {
@@ -522,15 +488,16 @@
 	status = "okay";
 };
 
+
 &sai2 {
 	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
 	clock-names = "pclk", "x8k", "x11k";
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_b>;
 	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_b>;
-	status = "okay";
-
+	status = "okay";	
 	sai2a: audio-controller@4400b004 {
+	
 		#clock-cells = <0>;
 		dma-names = "tx";
 		clocks = <&rcc SAI2_K>;
@@ -539,34 +506,30 @@
 
 		sai2a_port: port {
 			sai2a_endpoint: endpoint {
-				remote-endpoint = <&cs42l51_tx_endpoint>;
+				remote-endpoint = <&ad1938_rx_endpoint>;
 				format = "i2s";
-				mclk-fs = <256>;
-				dai-tdm-slot-num = <2>;
-				dai-tdm-slot-width = <32>;
 			};
 		};
 	};
 
 	sai2b: audio-controller@4400b024 {
+		//#clock-cells = <0>;
 		dma-names = "rx";
 		st,sync = <&sai2a 2>;
 		clocks = <&rcc SAI2_K>, <&sai2a>;
-		clock-names = "sai_ck", "MCLK";
+		clock-names = "sai_ck";
 		status = "okay";
 
 		sai2b_port: port {
 			sai2b_endpoint: endpoint {
-				remote-endpoint = <&cs42l51_rx_endpoint>;
+				remote-endpoint = <&ad1938_tx_endpoint>;
 				format = "i2s";
-				mclk-fs = <256>;
-				dai-tdm-slot-num = <2>;
-				dai-tdm-slot-width = <32>;
 			};
 		};
 	};
 };
 
+
 &sdmmc1 {
 	pinctrl-names = "default", "opendrain", "sleep";
 	pinctrl-0 = <&sdmmc1_b4_pins_a>;
@@ -603,7 +566,40 @@
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&spi5_pins_a>;
 	pinctrl-1 = <&spi5_sleep_pins_a>;
-	status = "disabled";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	cs-gpios = <&gpiof 6 0>;
+	status = "okay";
+	
+	ad1938: ad1938@0{
+		compatible = "adi,ad1938";
+		reg = <0>;
+		#sound-dai-cells = <0>;
+		clocks = <&sai2a>;
+		//clock-names = "MCLK";
+    	spi-max-frequency = <1000000>;
+		status = "okay";
+
+
+		ad1938_port: port {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			ad1938_tx_endpoint: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&sai2b_endpoint>;
+				frame-slave;
+				bitclock-slave;
+			};
+
+			ad1938_rx_endpoint: endpoint@1{
+				reg = <1>;
+				remote-endpoint = <&sai2a_endpoint>; //<&sai2b_endpoint>;
+				frame-slave;
+				bitclock-slave;
+			}; 
+		};
+	};
 };
 
 &sram {
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index e5d231a63..b22cd51e5 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -315,14 +315,14 @@ config SND_SOC_AD1836
 	tristate
 
 config SND_SOC_AD193X
-	tristate
+	tristate "Analog Devices AD193X CODEC"
 
 config SND_SOC_AD193X_SPI
-	tristate
+	tristate "Analog Devices AD193X CODEC - SPI"
 	select SND_SOC_AD193X
 
 config SND_SOC_AD193X_I2C
-	tristate
+	tristate "Analog Devices AD193X CODEC - I2C"
 	select SND_SOC_AD193X
 
 config SND_SOC_AD1980
diff --git a/sound/soc/codecs/ad193x.c b/sound/soc/codecs/ad193x.c
index 980e024a5..b77d9b12f 100644
--- a/sound/soc/codecs/ad193x.c
+++ b/sound/soc/codecs/ad193x.c
@@ -4,6 +4,7 @@
  *
  * Copyright 2010 Analog Devices Inc.
  */
+#define DEBUG 1
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -83,7 +84,7 @@ static const struct snd_kcontrol_new ad193x_adc_snd_controls[] = {
 static const struct snd_soc_dapm_widget ad193x_dapm_widgets[] = {
 	SND_SOC_DAPM_DAC("DAC", "Playback", SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_PGA("DAC Output", AD193X_DAC_CTRL0, 0, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("PLL_PWR", AD193X_PLL_CLK_CTRL0, 0, 1, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("PLL_PWR", AD193X_PLL_CLK_CTRL0, 0, 0, NULL, 0),//MD
 	SND_SOC_DAPM_SUPPLY("SYSCLK", AD193X_PLL_CLK_CTRL0, 7, 0, NULL, 0),
 	SND_SOC_DAPM_VMID("VMID"),
 	SND_SOC_DAPM_OUTPUT("DAC1OUT"),
@@ -145,6 +146,8 @@ static inline bool ad193x_has_adc(const struct ad193x_priv *ad193x)
 
 static int ad193x_mute(struct snd_soc_dai *dai, int mute)
 {
+				printk(" test ad1938 component ad193x_mute");
+
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(dai->component);
 
 	if (mute)
@@ -161,6 +164,8 @@ static int ad193x_mute(struct snd_soc_dai *dai, int mute)
 static int ad193x_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 			       unsigned int rx_mask, int slots, int width)
 {
+			printk(" test ad1938 component ad193x_set_tdm_slot");
+
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(dai->component);
 	unsigned int channels;
 
@@ -194,6 +199,9 @@ static int ad193x_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 static int ad193x_set_dai_fmt(struct snd_soc_dai *codec_dai,
 		unsigned int fmt)
 {
+		printk(" test ad1938 component ad193x_set_dai_fmt");
+	return 0;
+
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(codec_dai->component);
 	unsigned int adc_serfmt = 0;
 	unsigned int dac_serfmt = 0;
@@ -281,38 +289,66 @@ static int ad193x_set_dai_fmt(struct snd_soc_dai *codec_dai,
 static int ad193x_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 		int clk_id, unsigned int freq, int dir)
 {
-	struct snd_soc_component *component = codec_dai->component;
-	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
-	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
-
-	if (clk_id == AD193X_SYSCLK_MCLK) {
-		/* MCLK must be 512 x fs */
-		if (dir == SND_SOC_CLOCK_OUT || freq != 24576000)
-			return -EINVAL;
+	printk(" test ad1938 component ad193x_set_dai_sysclk");
+
+//	struct snd_soc_component *component = codec_dai->component;
+//	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+//	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
+//
+//	if (clk_id == AD193X_SYSCLK_MCLK) {
+//		/* MCLK must be 512 x fs */
+//		if (dir == SND_SOC_CLOCK_OUT || freq != 24576000)
+//			return -EINVAL;
+//
+//		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
+//				   AD193X_PLL_SRC_MASK,
+//				   AD193X_PLL_DAC_SRC_MCLK |
+//				   AD193X_PLL_CLK_SRC_MCLK);
+//
+//		snd_soc_dapm_sync(dapm);
+//		return 0;
+//	}
+//	
+//	switch (freq) {
+//	case 12288000:
+//	case 18432000:
+//	case 24576000:
+//	case 36864000:
+//		ad193x->sysclk = freq;
+//		return 0;
+//	}
+//	return -EINVAL;
+	return 0;
+}
 
-		regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
-				   AD193X_PLL_SRC_MASK,
-				   AD193X_PLL_DAC_SRC_MCLK |
-				   AD193X_PLL_CLK_SRC_MCLK);
+static int ad193x_set_pll(struct snd_soc_dai *codec_dai, int pll_id, int source,
+		unsigned int freq_in, unsigned int freq_out)
+{
+//	struct snd_soc_component *component = codec_dai->component;
+//	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+//	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
+//	
+//	
+//	
+//			regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL1,
+//				   AD193X_PLL_SRC_MASK,
+//				   AD193X_PLL_DAC_SRC_MCLK |
+//				   AD193X_PLL_CLK_SRC_MCLK);
+//
+//		snd_soc_dapm_sync(dapm);
+//	
+//	
+//   return -EINVAL;
+	
+	return 0;
 
-		snd_soc_dapm_sync(dapm);
-		return 0;
-	}
-	switch (freq) {
-	case 12288000:
-	case 18432000:
-	case 24576000:
-	case 36864000:
-		ad193x->sysclk = freq;
-		return 0;
-	}
-	return -EINVAL;
 }
 
 static int ad193x_hw_params(struct snd_pcm_substream *substream,
 		struct snd_pcm_hw_params *params,
 		struct snd_soc_dai *dai)
 {
+	return 0;
 	int word_len = 0, master_rate = 0;
 	struct snd_soc_component *component = dai->component;
 	struct ad193x_priv *ad193x = snd_soc_component_get_drvdata(component);
@@ -346,8 +382,8 @@ static int ad193x_hw_params(struct snd_pcm_substream *substream,
 		break;
 	}
 
-	regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
-			    AD193X_PLL_INPUT_MASK, master_rate);
+/*	regmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,
+			    AD193X_PLL_INPUT_MASK, master_rate);*/
 
 	regmap_update_bits(ad193x->regmap, AD193X_DAC_CTRL2,
 			    AD193X_DAC_WORD_LEN_MASK,
@@ -356,13 +392,15 @@ static int ad193x_hw_params(struct snd_pcm_substream *substream,
 	if (ad193x_has_adc(ad193x))
 		regmap_update_bits(ad193x->regmap, AD193X_ADC_CTRL1,
 				   AD193X_ADC_WORD_LEN_MASK, word_len);
-
+printk(" test ad1938 component ad193x_hw_params");
 	return 0;
 }
 
 static int ad193x_startup(struct snd_pcm_substream *substream,
 			  struct snd_soc_dai *dai)
 {
+	printk("test ad1938 component ad193x_startup");
+
 	return snd_pcm_hw_constraint_list(substream->runtime, 0,
 				   SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
 				   &constr);
@@ -374,6 +412,7 @@ static const struct snd_soc_dai_ops ad193x_dai_ops = {
 	.digital_mute = ad193x_mute,
 	.set_tdm_slot = ad193x_set_tdm_slot,
 	.set_sysclk	= ad193x_set_dai_sysclk,
+	.set_pll = ad193x_set_pll,
 	.set_fmt = ad193x_set_dai_fmt,
 };
 
@@ -417,11 +456,11 @@ static struct snd_soc_dai_driver ad193x_no_adc_dai = {
 static void ad193x_reg_default_init(struct ad193x_priv *ad193x)
 {
 	static const struct reg_sequence reg_init[] = {
-		{  0, 0x99 },	/* PLL_CLK_CTRL0: pll input: mclki/xi 12.288Mhz */
-		{  1, 0x04 },	/* PLL_CLK_CTRL1: no on-chip Vref */
-		{  2, 0x40 },	/* DAC_CTRL0: TDM mode */
+		{  0, 0xD8 },	/* PLL_CLK_CTRL0: pll input: mclki/xi 12.288Mhz */ /*0b10100000*/
+		{  1, 0x04 },	/* PLL_CLK_CTRL1: no on-chip Vref */ /*0b00000100*/
+		{  2, 0x00 },	/* DAC_CTRL0: TDM mode */ /*0x40*/ /*0b00000000*/
 		{  3, 0x00 },	/* DAC_CTRL1: reset */
-		{  4, 0x1A },	/* DAC_CTRL2: 48kHz de-emphasis, unmute dac */
+		{  4, 0x1A },	/* DAC_CTRL2: 48kHz de-emphasis, unmute dac */ /*0b00000010*/
 		{  5, 0x00 },	/* DAC_CHNL_MUTE: unmute DAC channels */
 		{  6, 0x00 },	/* DAC_L1_VOL: no attenuation */
 		{  7, 0x00 },	/* DAC_R1_VOL: no attenuation */
@@ -481,10 +520,19 @@ static int ad193x_component_probe(struct snd_soc_component *component)
 		if (ret)
 			return ret;
 	}
+	
+	
 
 	return 0;
 }
 
+///*static int ad193x_of_xlate_dai_id(struct snd_soc_component *component,
+//				   struct device_node *endpoint)
+//{
+//	/* return dai id 0, whatever the endpoint index */
+//	return 0;
+//}*/
+//
 static const struct snd_soc_component_driver soc_component_dev_ad193x = {
 	.probe			= ad193x_component_probe,
 	.controls		= ad193x_snd_controls,
@@ -493,12 +541,15 @@ static const struct snd_soc_component_driver soc_component_dev_ad193x = {
 	.num_dapm_widgets	= ARRAY_SIZE(ad193x_dapm_widgets),
 	.dapm_routes		= audio_paths,
 	.num_dapm_routes	= ARRAY_SIZE(audio_paths),
+//	.of_xlate_dai_id	= ad193x_of_xlate_dai_id,
 	.idle_bias_on		= 1,
 	.use_pmdown_time	= 1,
 	.endianness		= 1,
 	.non_legacy_dai_naming	= 1,
 };
 
+
+
 const struct regmap_config ad193x_regmap_config = {
 	.max_register = AD193X_NUM_REGS - 1,
 };
@@ -507,8 +558,8 @@ EXPORT_SYMBOL_GPL(ad193x_regmap_config);
 int ad193x_probe(struct device *dev, struct regmap *regmap,
 		 enum ad193x_type type)
 {
-	struct ad193x_priv *ad193x;
-
+	struct ad193x_priv *ad193x;	
+	
 	if (IS_ERR(regmap))
 		return PTR_ERR(regmap);
 
diff --git a/sound/soc/codecs/ad193x.h b/sound/soc/codecs/ad193x.h
index 377854712..7ef7fa93d 100644
--- a/sound/soc/codecs/ad193x.h
+++ b/sound/soc/codecs/ad193x.h
@@ -23,23 +23,41 @@ int ad193x_probe(struct device *dev, struct regmap *regmap,
 		 enum ad193x_type type);
 
 #define AD193X_PLL_CLK_CTRL0    0x00
-#define AD193X_PLL_POWERDOWN           0x01
+
+#define AD193X_PLL_POWERDOWN    0x01
 #define AD193X_PLL_INPUT_MASK   0x6
 #define AD193X_PLL_INPUT_256    (0 << 1)
 #define AD193X_PLL_INPUT_384    (1 << 1)
 #define AD193X_PLL_INPUT_512    (2 << 1)
 #define AD193X_PLL_INPUT_768    (3 << 1)
+#define AD193X_PLL_OUTPUT_MASK  0x18
+#define AD193X_PLL_OUTPUT_XTAL  (0 << 3)
+#define AD193X_PLL_OUTPUT_256FS (1 << 3)
+#define AD193X_PLL_OUTPUT_512FS (2 << 3)
+#define AD193X_PLL_OUTPUT_OFF   (3 << 3)
+#define AD193X_PLL_IN_MASK  	0x60
+#define AD193X_PLL_IN_MCLKI     (0 << 5)
+#define AD193X_PLL_IN_DLRCLK    (1 << 5)
+#define AD193X_PLL_IN_ALRCLK    (2 << 5)
+#define AD193X_PLL_ENABLE       (1 << 7)
+
 #define AD193X_PLL_CLK_CTRL1    0x01
-#define AD193X_PLL_SRC_MASK	0x03
+
+#define AD193X_PLL_SRC_MASK		0x03
 #define AD193X_PLL_DAC_SRC_PLL  0
 #define AD193X_PLL_DAC_SRC_MCLK 1
-#define AD193X_PLL_CLK_SRC_PLL  (0 << 1)
-#define AD193X_PLL_CLK_SRC_MCLK	(1 << 1)
+#define AD193X_PLL_ADC_SRC_PLL  (0 << 1)
+#define AD193X_PLL_ADC_SRC_MCLK	(1 << 1)
+#define AD193X_PLL_SRC_MASK		0x04
+#define AD193X_PLL_VREF_ENABLE  (1 << 2)
+
 #define AD193X_DAC_CTRL0        0x02
-#define AD193X_DAC_POWERDOWN           0x01
+
+#define AD193X_DAC_POWERDOWN        0x01
 #define AD193X_DAC_SERFMT_MASK		0xC0
 #define AD193X_DAC_SERFMT_STEREO	(0 << 6)
 #define AD193X_DAC_SERFMT_TDM		(1 << 6)
+
 #define AD193X_DAC_CTRL1        0x03
 #define AD193X_DAC_CHAN_SHFT    1
 #define AD193X_DAC_CHAN_MASK    (3 << AD193X_DAC_CHAN_SHFT)
diff --git a/sound/soc/stm/Kconfig b/sound/soc/stm/Kconfig
index bbade257f..823c81f2d 100644
--- a/sound/soc/stm/Kconfig
+++ b/sound/soc/stm/Kconfig
@@ -1,6 +1,14 @@
 # SPDX-License-Identifier: GPL-2.0-only
 menu "STMicroelectronics STM32 SOC audio support"
 
+config SND_SOC_STM32_AD1938
+	tristate "STM32 AD1930 machine driver"
+	depends on (ARCH_STM32 && OF) || COMPILE_TEST
+	depends on SND_SOC_STM32_SAI
+	depends on SND_SOC
+	help
+	  Say Y if you want to enable ad1938 board
+
 config SND_SOC_STM32_SAI
 	tristate "STM32 SAI interface (Serial Audio Interface) support"
 	depends on (ARCH_STM32 && OF) || COMPILE_TEST
diff --git a/sound/soc/stm/Makefile b/sound/soc/stm/Makefile
index 3143c0b47..5c9f66b5c 100644
--- a/sound/soc/stm/Makefile
+++ b/sound/soc/stm/Makefile
@@ -16,3 +16,8 @@ obj-$(CONFIG_SND_SOC_STM32_SPDIFRX) += snd-soc-stm32-spdifrx.o
 
 #DFSDM
 obj-$(CONFIG_SND_SOC_STM32_DFSDM) += stm32_adfsdm.o
+
+#AD1938
+obj-$(CONFIG_SND_SOC_STM32_AD1938) += stm32_ad1938.o
+
+
diff --git a/sound/soc/stm/stm32_ad1938.c b/sound/soc/stm/stm32_ad1938.c
new file mode 100644
index 000000000..3a3a1ae7a
--- /dev/null
+++ b/sound/soc/stm/stm32_ad1938.c
@@ -0,0 +1,252 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * stm32_ad1938 - ST ASoC driver for boards with ad1938 codec.
+ *
+ * Copyright (C) 2012 STMicroelectronics
+ *
+ * Author: Matteo D'Aria <matteo.daria@st.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+
+#include <sound/soc.h>
+
+#include "../codecs/ad193x.h"
+#include "stm32_sai.h"
+
+static const struct snd_soc_dapm_widget stm_asoc_ad1938_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("Line In Jack 1", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack 2", NULL),
+	SND_SOC_DAPM_HP("Line Out Jack 1", NULL),
+	SND_SOC_DAPM_HP("Line Out Jack 2", NULL),	
+};
+
+static int stm_asoc_ad1938_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+//	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+//	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+//	struct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);
+//	struct platform_device *pdev_sync_provider = of_find_device_by_node(sai->np_sync_provider_sai_sub);
+//	struct stm32_sai_sub_data *sai_provider = platform_get_drvdata(pdev_sync_provider);
+
+	
+//	int ret;
+//
+//	/*MD: These functions to setup codec. Depends on the function which are
+//	defined in the codec driver, under snd_soc_dai_ops (I believe)
+//	*/
+//	ret = snd_soc_dai_set_pll(codec_dai, WM8904_FLL_MCLK, WM8904_FLL_MCLK,
+//		32768, params_rate(params) * 256);
+//	if (ret < 0) {
+//		pr_err("%s - failed to set wm8904 codec PLL.", __func__);
+//		return ret;
+//	}
+//
+//	/*
+//	 * As here wm8904 use FLL output as its system clock
+//	 * so calling set_sysclk won't care freq parameter
+//	 * then we pass 0
+//	 */
+//	ret = snd_soc_dai_set_sysclk(codec_dai, WM8904_CLK_FLL,
+//			0, SND_SOC_CLOCK_IN);
+//	if (ret < 0) {
+//		pr_err("%s -failed to set wm8904 SYSCLK\n", __func__);
+//		return ret;
+//	}
+//
+printk(" MACHINE HW PARAM ");
+	return 0;
+}
+
+static const struct snd_soc_ops stm_asoc_ad1938_ops = {
+	.hw_params = stm_asoc_ad1938_hw_params,
+};
+
+SND_SOC_DAILINK_DEFS(pcm1,
+	DAILINK_COMP_ARRAY(COMP_EMPTY()),
+	DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "ad193x-hifi")),
+	DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(pcm2,
+	DAILINK_COMP_ARRAY(COMP_EMPTY()),
+	DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "ad193x-hifi")),
+	DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+/* Slide 8 */
+static struct snd_soc_dai_link stm_asoc_ad1938_dailink[] = {
+	{
+	.name = "ad1938_1",
+	.stream_name = "AD1938 PCM1",
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+		| SND_SOC_DAIFMT_NB_NF
+		| SND_SOC_DAIFMT_CBS_CFS,
+	.ops = &stm_asoc_ad1938_ops,
+	SND_SOC_DAILINK_REG(pcm1),
+	},
+	{
+	.name = "ad1938_2",
+	.stream_name = "AD1938 PCM2",
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+		| SND_SOC_DAIFMT_NB_NF
+		| SND_SOC_DAIFMT_CBS_CFS,
+	.ops = &stm_asoc_ad1938_ops,
+	SND_SOC_DAILINK_REG(pcm2),		
+	}		
+};
+
+/* Slide 7 */
+static struct snd_soc_card stm_asoc_ad1938_card = {
+	.name = "stm_asoc_ad1938",
+	.owner = THIS_MODULE,
+	.dai_link = stm_asoc_ad1938_dailink,
+	.num_links = 2,
+	.dapm_widgets = stm_asoc_ad1938_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(stm_asoc_ad1938_dapm_widgets),
+	.fully_routed = true,
+};
+
+static int stm_asoc_ad1938_dt_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *codec_np, *cpu_np;
+	struct snd_soc_card *card = &stm_asoc_ad1938_card;
+	struct snd_soc_dai_link *dailink1 = &stm_asoc_ad1938_dailink[0];
+    struct snd_soc_dai_link *dailink2 = &stm_asoc_ad1938_dailink[1];
+
+	int ret;
+
+	if (!np) {
+		dev_err(&pdev->dev, "only device tree supported\n");
+		return -EINVAL;
+	}
+
+	ret = snd_soc_of_parse_card_name(card, "stm,model"); /* Looks to the DT bindings */
+	if (ret) {
+		dev_err(&pdev->dev, "failed to parse card name\n");
+		return ret;
+	}
+
+	ret = snd_soc_of_parse_audio_routing(card, "stm,audio-routing"); /* Looks to the DT bindings */
+	if (ret) {
+		dev_err(&pdev->dev, "failed to parse audio routing\n");
+		return ret;
+	}
+	
+	cpu_np = of_parse_phandle(np, "stm,sai-controller", 0); /* Looks to the DT bindings */
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "failed to get dai and pcm info\n");
+		ret = -EINVAL;
+		return ret;
+	}
+	dailink1->cpus->of_node = cpu_np;
+	dailink1->platforms->of_node = cpu_np;
+	of_node_put(cpu_np);
+
+	codec_np = of_parse_phandle(np, "stm,audio-codec", 0); /* Looks to the DT bindings */
+	if (!codec_np) {
+		dev_err(&pdev->dev, "failed to get codec info\n");
+		ret = -EINVAL;
+		return ret;
+	}
+	dailink1->codecs->of_node = codec_np;
+	of_node_put(codec_np);
+
+	cpu_np = of_parse_phandle(np, "stm,sai-controller", 1); /* Looks to the DT bindings */
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "failed to get dai and pcm info\n");
+		ret = -EINVAL;
+		return ret;
+	}
+
+	dailink2->cpus->of_node = cpu_np;
+	dailink2->platforms->of_node = cpu_np;
+	of_node_put(cpu_np);
+	
+	codec_np = of_parse_phandle(np, "stm,audio-codec", 0); /* Looks to the DT bindings */
+	if (!codec_np) {
+		dev_err(&pdev->dev, "failed to get codec info\n");
+		ret = -EINVAL;
+		return ret;
+	}
+	dailink2->codecs->of_node = codec_np;
+	of_node_put(codec_np);
+
+
+	return 0;
+}
+
+static int stm_asoc_ad1938_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &stm_asoc_ad1938_card;
+	//struct snd_soc_dai_link *dailink = &stm_asoc_ad1938_dailink;
+	int id, ret;
+
+	card->dev = &pdev->dev;
+	ret = stm_asoc_ad1938_dt_init(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to init dt info\n");
+		return ret;
+	}
+
+	/*id = of_alias_get_id((struct device_node *)dailink->cpus->of_node, "ssc");
+	ret = atmel_ssc_set_audio(id);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "failed to set SSC %d for audio\n", id);
+		return ret;
+	}*/ /*MD: ??? */
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed\n");
+		goto err_set_audio;
+	}
+
+	return 0;
+
+err_set_audio:
+	//atmel_ssc_put_audio(id);
+	return ret;
+}
+
+static int stm_asoc_1938_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+//	struct snd_soc_dai_link *dailink = &stm_asoc_ad1938_dailink;
+	int id;
+
+	//id = of_alias_get_id((struct device_node *)dailink->cpus->of_node, "ssc");
+
+	snd_soc_unregister_card(card);
+	//atmel_ssc_put_audio(id);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id stm_asoc_ad1938_dt_ids[] = {
+	{ .compatible = "stm,asoc-ad1938", },    /*DT compatible property */
+	{ }
+};
+MODULE_DEVICE_TABLE(of, stm_asoc_ad1938_dt_ids);
+#endif
+
+static struct platform_driver stm_asoc_ad1938_driver = {
+	.driver = {
+		.name = "stm-ad1938-audio",
+		.of_match_table = of_match_ptr(stm_asoc_ad1938_dt_ids),
+		.pm		= &snd_soc_pm_ops,
+	},
+	.probe = stm_asoc_ad1938_probe,
+	.remove = stm_asoc_1938_remove,
+};
+
+module_platform_driver(stm_asoc_ad1938_driver);
+
+/* Module information */
+MODULE_AUTHOR("Matteo D'Aria <matteo.daria@st.com>");
+MODULE_DESCRIPTION("ALSA SoC machine driver for STM32MP1DK with AD1938 codec");
+MODULE_LICENSE("GPL");
-- 
2.17.1

